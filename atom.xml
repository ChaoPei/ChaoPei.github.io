<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾荒志</title>
  
  <subtitle>虚怀若谷，大智若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://murphypei.github.io/"/>
  <updated>2021-03-03T08:10:38.140Z</updated>
  <id>https://murphypei.github.io/</id>
  
  <author>
    <name>murphypei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 不同平台下软链接问题</title>
    <link href="https://murphypei.github.io//blog/2021/03/git-symlink.html"/>
    <id>https://murphypei.github.io//blog/2021/03/git-symlink.html</id>
    <published>2021-03-03T07:05:06.000Z</published>
    <updated>2021-03-03T08:10:38.140Z</updated>
    
    <content type="html"><![CDATA[<p>早就听说不同平台软链接兼容问题很大，最近遇上了，记录一下这个问题。</p><a id="more"></a><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>问题场景很常见也很简单。有一个 C++ 项目，在 Linux 下开发，引用了一些第三方库，比如 opencv，其中的 lib 有些是软链接的形式。在 windows 下拉取仓库之后，发现软链接失效了（不影响 windows 平台本身的运行）。我使用 clion 将 windows 的代码同步到远程开发机，则编译无法进行，文件格式错误。原因在于不同操作系统使用的文件系统不同，因此软链接失效了。不同文件系统软链接不兼容的问题，网上自己找找一大堆，实现不同，没啥说的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>现在的 git 都支持了软链接的兼容处理，安装的时候有个 symlink 选项，勾上即可。另外需要在 clone 的时候处理：</p><ul><li>首先，使用<strong>以管理员方式</strong>打开 git bash，因为 windows 创建软链接需要管理员权限。</li><li>clone 的时候必须<strong>明确指定</strong>兼容软链接。<code>git clone -c core.symlinks=true ...</code>。在 亲测 <code>.gitconfig</code> 中设置无效。</li></ul><p>这样 clone 下来的仓库里，之前的软链接就变成了 windows 系统中的快捷方式。但是这种快捷方式通过 clion 同步到 Linux 中就是自动的软链接，非常 nice。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>windows 下的 git bash 可以通过创造快捷方式的办法兼容 Linux 下的软链接，并且同步到 Linux 中还能保持软链接。</li><li>clion 的远程开发落后 vscode 一个段位，本质就是 rsync 文件同步和 ssh 执行一些命令，因此当遇到这种 windows 和 Linux 中不兼容的文件，这种简单的同步方式必然 GG。</li></ul><p>为了解决这个问题顺便测试了最新的 vscode 的 C/C++ 和 cmake 插件，已经解决之前的 includePath 和跳转提示问题，加上强大的 remote 和 git，我觉得 vscode 取代 clion 已经是近在咫尺了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就听说不同平台软链接兼容问题很大，最近遇上了，记录一下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://murphypei.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://murphypei.github.io/tags/git/"/>
    
      <category term="symlink" scheme="https://murphypei.github.io/tags/symlink/"/>
    
      <category term="linux" scheme="https://murphypei.github.io/tags/linux/"/>
    
      <category term="windows" scheme="https://murphypei.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL 渲染管线简介</title>
    <link href="https://murphypei.github.io//blog/2021/02/opengl-render.html"/>
    <id>https://murphypei.github.io//blog/2021/02/opengl-render.html</id>
    <published>2021-02-20T03:25:17.000Z</published>
    <updated>2021-02-20T10:17:43.860Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 OpenGL 渲染特效的东西，需要补充一些基础知识，遇到不错的介绍文章，整理摘录。</p><a id="more"></a><h2 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2><p>在 OpenGL 的世界里，任何事物是处于 3D 空间中的，而屏幕和窗口显示的却是 2D，所以 OpenGL 干的事情基本就是 <strong>把3D坐标转变为适应屏幕的2D像素</strong>。</p><p>3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的<strong>图形渲染管线</strong>管理的，图形渲染管线可以被划分为两个主要部分：</p><blockquote><p>图形渲染管线(Graphics Pipeline)，大多译为<strong>管线</strong>，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></blockquote><ol><li>第一部分把你的 3D 坐标转换为 2D 坐标。</li><li>第二部分是把 2D 坐标转变为实际的有颜色的像素。</li></ol><blockquote><p>另外，<strong>2D 坐标</strong>和<strong>像素</strong>也是不同的概念，2D 坐标精确表示一个点在 2D 空间中的<strong>位置</strong>，而 2D 像素是这个点的<strong>近似值</strong>，2D 像素受到你的屏幕/窗口分辨率的限制。<br>简单来说就是坐标是一个包含无限个数值的集合，像素则是极小的有限个区域。</p></blockquote><p>现在我们就简单地讲讲图形渲染管线内，数据处理的过程：</p><ul><li>管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。</li><li>管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。</li><li>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且<strong>很容易并行执行</strong>。</li><li>由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据，这些小程序叫做<strong>着色器(Shader)</strong>。<ul><li>着色器有好几种，其中有些着色器允许开发者自己配置，以更细致地控制管线中的特定部分。</li><li>着色器运行在GPU上。</li><li>OpenGL 着色器是用 OpenGL 着色器语言 (OpenGL Shading Language 即 GLSL) 写成的。</li></ul></li></ul><p>关于着色器我们之后再讨论，回到管线，下面是一个图形渲染管线的每个阶段的抽象展示，其中蓝色的是我们可以注入自定义的着色器的部分。</p><p><img src="/images/posts/opengl/render_pipeline/opengl-render.png" alt></p><p>如你所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段，我们下面会概括性地解释一下渲染管线的每个部分，从而对图形渲染管线的工作方式有个大概了解。</p><h3 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h3><p>我们需要先简单了解下图元。</p><p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，你需要去指定这些数据所表示的渲染类型，比如说：传入坐标等数据后，你想让 OpenGL 把这些数据渲染成一系列的点？一系列的三角形？还是线？以上要给 OpenGL 的这些信息就叫<strong>图元(Primitive)</strong>，任何一个绘制指令的调用都将是<strong>把图元传递给 OpenGL</strong>。这是其中的几种：<code>GL_POINTS</code>、<code>GL_TRIANGLES</code>、<code>GL_LINE_STRIP</code>（点，三角形，线）。</p><blockquote><p>这里我理解三角形就是代表面，因为如果我们想渲染一块区域，就应该使用三角形。</p></blockquote><p>接下来正式进入渲染管线的介绍。这也是初学者比较头晕的部分，本文将分开一步步具体分析。</p><h3 id="渲染管线流程"><a href="#渲染管线流程" class="headerlink" title="渲染管线流程"></a>渲染管线流程</h3><p>现在假设我们的目的就是画出一个三角形。下面我们对渲染管线中每个流程一一说明。</p><p>首先，我们要以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，<strong>一个 3D 坐标的数据的集合就是一个顶点(Vertex)</strong>；这个数组就是一系列顶点的集合，我们叫他<strong>顶点数据(Vertex Data)</strong>（简单起见，我们先假定每个顶点只由一个3D位置和一些颜色值组成）。</p><blockquote><p>这里再次强调，OpenGL 是 3D 的，因此内部表示的坐标都是 3D 坐标，哪怕我们想画的是 2D 图形。另外展示的都是屏幕像素，是 2D 的，因此渲染管线必须包含坐标处理。这里要切记。</p></blockquote><p><img src="/images/posts/opengl/render_pipeline/vertex-data.png" alt></p><p>顶点数据会进入<strong>顶点着色器(Vertex Shader)</strong>，它把一个单独的顶点作为输入，顶点着色器主要的目的是把输入的 3D 坐标转为另一种 3D 坐标（之后会解释），同时对顶点属性进行一些基本处理。</p><p><img src="/images/posts/opengl/render_pipeline/vertex-shader.png" alt></p><p>顶点着色器输出的所有顶点会进入<strong>图元装配(Primitive Assembly)</strong>阶段，它将所有的点装配成<strong>指定图元的形状</strong>（这里的例子中是一个三角形，如果是 <code>GL_POINTS</code>，那么就是一个个的点）。</p><p><img src="/images/posts/opengl/render_pipeline/shape-assembly.png" alt></p><p>图元装配阶段的输出会传递给<strong>几何着色器(Geometry Shader)</strong>，几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状，在这个例子里，它生成了另一个三角形。</p><p><img src="/images/posts/opengl/render_pipeline/geometry-shader.png" alt></p><p>几何着色器的输出会被传入<strong>光栅化阶段(Rasterization Stage)</strong>，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)（<strong>OpenGL 的一个片段是 OpenGL 渲染一个像素所需的所有数据</strong>）。但在片段着色器运行之前还会执行裁切(Clipping)，裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p><img src="/images/posts/opengl/render_pipeline/rasterization.png" alt></p><p>输出的片段(Fragment)将会传入片段着色器(Fragment Shader)，它主要作用是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方，通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可被用来计算最终像素的颜色。</p><p><img src="/images/posts/opengl/render_pipeline/fragment-shader.png" alt></p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 Alpha 测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用以判断这个像素是在前面还是后面，决定是否丢弃。这个阶段也会检查alpha 值（alpha值 定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p><img src="/images/posts/opengl/render_pipeline/test-blending.png" alt></p><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。<strong>但其实对于大多数场合，我们只需要配置顶点和片段着色器就行了</strong>（几何着色器是可选的，通常使用它默认的着色器就行了）。</p><p>在现代 OpenGL 中，我们也必须定义<strong>至少一个顶点着色器和一个片段着色器</strong>（GPU 中没有默认的顶点/片段着色器），因此刚开始学习的时候可能会非常困难，在你能够渲染自己的第一个三角形之前，已经需要了解一大堆知识了。</p><h3 id="管线小结"><a href="#管线小结" class="headerlink" title="管线小结"></a>管线小结</h3><p>我们再梳理一次渲染管线的流程：</p><p><img src="/images/posts/opengl/render_pipeline/opengl-render.png" alt></p><ol><li>首先，我们以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，这个数组叫做<strong>顶点数据(Vertex Data)</strong>，是<strong>一系列顶点的集合</strong>。</li><li><strong>顶点着色器(Vertex Shader)</strong> 把顶点的 3D 坐标转为另一种 3D 坐标，同时允许我们对顶点属性进行一些基本处理。</li><li><strong>图元装配(Primitive Assembly)</strong> 将所有的点装配成指定图元的形状。</li><li><strong>几何着色器(Geometry Shader)</strong> 它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状，在我们这里，它生成了另一个三角形。</li><li><strong>光栅化阶段(Rasterization Stage)</strong> 会把图元映射为最终屏幕上相应的像素，生成片段(Fragment)，并执行裁切(Clipping)，丢弃超出你的视图以外的所有像素提升效率。</li><li><strong>片段着色器(Fragment Shader)</strong> 计算一个像素的最终颜色。</li><li><strong>Alpha测试和混合(Blending)</strong> 阶段检测片段的对应的深度（和模板(Stencil)）值，决定是否丢弃；这个阶段也会检查alpha值并对物体进行混合(Blend)。</li></ol><p>都理解了之后，我们将尝试渲染一个三角形。</p><h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>先记住以下三个概念：</p><ul><li>顶点数组对象：Vertex Array Object，<strong>VAO</strong></li><li>顶点缓冲对象：Vertex Buffer Object，<strong>VBO</strong></li><li>索引缓冲对象：Element Buffer Object，<strong>EBO</strong> 或 Index Buffer Object，<strong>IBO</strong></li></ul><p>就如管线的流程，想要让 OpenGL 绘制图形，我们必须先给 OpenGL 喂一些顶点数据，<strong>顶点输入</strong>实际上步骤并不少，过程并不简单。</p><p>首先 OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x，y，z）。然后，OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素：仅当 3D 坐标在 3 个轴（x、y、z）上都为 <strong>-1.0 到 1.0</strong> 的范围内时才处理它，而所有在所谓的<strong>标准化设备坐标(Normalized DeviceCoordinates)</strong>范围内的坐标才会最终呈现在屏幕上。</p><h4 id="标准化设备坐标-Normalized-Device-Coordinates-NDC"><a href="#标准化设备坐标-Normalized-Device-Coordinates-NDC" class="headerlink" title="标准化设备坐标(Normalized Device Coordinates, NDC)"></a>标准化设备坐标(Normalized Device Coordinates, NDC)</h4><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间，任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。</p><p>下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="/images/posts/opengl/render_pipeline/normalized-device-coordinates.png" alt></p><p>你的标准化设备坐标接着会变换为屏幕<strong>空间坐标(Screen-spaceCoordinates)</strong>，这是通过 <code>glViewport</code> 函数提供的数据，进行<strong>视口变换(ViewportTransform)</strong>完成的，所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个 3D 位置，我们要将它们以标准化设备坐标的形式（OpenGL 的可见区域）输入，所以我们定义为一个 float 数组为<strong>顶点数据(Vertex Data)</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//左</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//右</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span> <span class="comment">//上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 OpenGL 是在 3D 空间中工作的，而我们渲染的是一个 2D 三角形，我们将它顶点的 z 坐标设置为 0.0，这样子的话三角形每一点的 <strong>深度 (Depth)</strong>都是一样的，从而使它看上去像是 2D 的。深度可以理解为 z 坐标，它代表一个像素在空间中和你(屏幕)的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p><p>创建之后，我们要考虑如何传输。顶点数据是要从 CPU 发往 GPU 上参与运算的，顶点数据通过 CPU 输入到 GPU 的<strong>顶点着色器</strong>之前，我们先要在 GPU 上创建内存（显存）空间，用于储存我们的顶点数据，还要配置 OpenGL 如何读懂这些数据，并且指定其如何发送给显卡，然后才轮到<strong>顶点着色器</strong>处理我们在内存中指定的顶点。</p><p>但是，<strong>从 CPU 把数据发送到 GPU 是一个相对较慢的过程</strong>，每个顶点发送一次耗费的时间将会非常大，所以我们要一次性发送尽可能多的数据，因此我们需要一个中介：<strong>顶点缓冲对象(Vertex Buffer Objects, VBO)</strong>，来管理这内存，它会在 GPU 内存（显存）中储存大量顶点，因此我们就能一批一批发送大量顶点数据到 GPU 内存（显存）了。而当数据储存到 GPU 的内存（显存）中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><h3 id="顶点缓冲对象-VBO"><a href="#顶点缓冲对象-VBO" class="headerlink" title="顶点缓冲对象 VBO"></a>顶点缓冲对象 VBO</h3><p>VBO 可以将输入的顶点数据<strong>原封不动</strong>的存起来。</p><p>和 OpenGL 中的其它对象一样，这个缓冲必须要有一个独一无二的 ID，所以我们需要一个整形变量，再使用 <code>glGenBuffers</code> 函数，他会生成缓冲并返回对应的 ID 存到第二个参数上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO); <span class="comment">// glGenBuffers(缓冲区绑定对象目标数量，缓冲区对象名称(ID))</span></span><br><span class="line"><span class="comment">// glGenBuffers 可以产生多个 VBO，但是我们现在只要一个。如果你一次生成 10 个，第一个参数要改成 10，并且你就需要声明一个整形数组而不是一个整形变量。</span></span><br></pre></td></tr></table></figure><p>OpenGL 有很多缓冲对象类型，<strong>顶点缓冲对象</strong>的缓冲类型是 <code>GL_ARRAY_BUFFER</code>，OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 <code>glBindBuffer</code> 函数把新创建的缓冲<strong>绑定</strong>到 <code>GL_ARRAY_BUFFER</code> 目标上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO); <span class="comment">// glBindBuffer(目标缓冲类型, 对象名称(ID))</span></span><br></pre></td></tr></table></figure><p>要注意，<code>glGenBuffers</code> 只是生成缓冲，程序并不知道这个缓冲是什么类型。所以调用 <code>glBindBuffer</code> 并制定缓冲类型，我们才算真正创建了一个 VBO。</p><p>接下来我们要<strong>把顶点数据存到 VBO 上</strong>，调用 <code>glBufferData</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(</span><br><span class="line">    GL_ARRAY_BUFFER,  <span class="comment">//目标缓冲类型</span></span><br><span class="line">    <span class="keyword">sizeof</span>(vertices), <span class="comment">//传输数据的大小</span></span><br><span class="line">    vertices,         <span class="comment">//发送的实际数据</span></span><br><span class="line">    GL_STATIC_DRAW    <span class="comment">//管理给定的数据的方式</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glBufferData</code> 是一个专门用来<strong>把用户定义的数据复制到当前绑定缓冲</strong>的函数。</p><ol><li>第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到 <code>GL_ARRAY_BUFFER</code> 目标上。</li><li>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的 <code>sizeof</code> 计算出顶点数据大小就行。</li><li>第三个参数是我们希望发送的实际数据。</li><li>第四个参数指定了我们希望显卡如何管理给定的数据，它有三种形式：<ul><li><code>GL_STATIC_DRAW</code> ：数据不会或几乎不会改变。</li><li><code>GL_DYNAMIC_DRAW</code>：数据会被改变很多。</li><li><code>GL_STREAM_DRAW</code> ：数据每次绘制时都会改变。</li></ul></li></ol><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是 <code>GL_STATIC_DRAW</code>。如果一个缓冲中的数据将频繁被改变，那么使用的类型就应该是 <code>GL_DYNAMIC_DRAW</code> 或 <code>GL_STREAM_DRAW</code>，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><p>目前我们完成的是：</p><ol><li>建立一批顶点数据存在 vertices 数组里。</li><li>在显存上创建了一个 VBO。</li><li>将顶点数据存在了 VBO 中，GPU 可以通过 VBO 读取顶点数据。</li></ol><p>之前也提到了，VBO 只是将输入的顶点数据<strong>原封不动的保存在显存中供 GPU 使用</strong>，接下来我们需要对这些数据加以解释，<strong>输入数据的哪到哪是一个部分，每个部分对应什么</strong>，让 GPU 读懂。</p><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>由于我们需要画三角形，传入的数据是三个顶点，所以我们希望 VBO 内的数据会被解析为下面这样子：</p><p><img src="/images/posts/opengl/render_pipeline/vertex-property.png" alt></p><ul><li>位置数据被储存为 32 位（4 字节）浮点值。</li><li>每个位置包含 3 个这样的值。</li><li>在这 3 个值之间没有空隙（或其他值），这几个值在数组中紧密排列。</li><li>数据中第一个值在缓冲开始的位置 0 。</li></ul><p>有了这些信息我们就可以使用 <code>glVertexAttribPointer()</code> 函数告诉 OpenGL 该如何解析顶点数据了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(</span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">//指定要配置的Location</span></span><br><span class="line">    <span class="number">3</span>,                  <span class="comment">//指定顶点属性的大小</span></span><br><span class="line">    GL_FLOAT,           <span class="comment">//指定数据的类型</span></span><br><span class="line">    GL_FALSE,           <span class="comment">//是否希望数据被标准化</span></span><br><span class="line">    <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>),  <span class="comment">//连续的顶点属性组之间的间隔</span></span><br><span class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>            <span class="comment">//偏移量</span></span><br><span class="line">);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code> 函数的参数非常多，这里逐一介绍它们：</p><ol><li>第一个参数<strong>指定我们要配置的顶点属性</strong>，我们之后需要在顶点着色器中使用 <code>layout(location = 0)</code> 定义 position 顶点属性的位置值(Location)。把顶点属性的位置值同样设置为 0 。</li><li>第二个参数<strong>指定顶点属性的大小</strong>，顶点属性是一个 <code>vec3</code>，它由 3个 值组成，所以大小是 3 。</li><li>第三个参数<strong>指定数据的类型</strong>，这里是 <code>GL_FLOAT</code> (GLSL 中 <code>vec*</code> 都是由浮点数值组成的)。</li><li>第四个参数定义我们<strong>是否希望数据被标准化</strong>(Normalize)，如果我们置为 <code>GL_TRUE</code>，所有数据都会被映射到 0 到 1 之间（对于有符号型signed数据是-1），我们把它置为 <code>GL_FALSE</code>。</li><li>第五个参数叫做步长(Stride)，它告诉我们在<strong>连续的顶点属性组之间的间隔</strong>，由于下个组位置数据在 3 个 float 之后，我们把步长设置为 <code>3 * sizeof(float)</code>，要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以<strong>设置为 0 来让 OpenGL 决定</strong>具体步长是多少（只有当数值是紧密排列时才可用），一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔。</li><li>最后一个参数的类型是 <code>void*</code>，所以需要我们进行这个奇怪的强制类型转换，它表示位置数据在缓冲中起始位置的<strong>偏移量(Offset)</strong>，由于位置数据在数组的开头，所以这里是 0，我们会在后面详细解释这个参数。</li></ol><p>如果程序中可以有多个 VBO，OpenGL怎么判断从哪个 VBO 获取呢？绑定是 OpenGL 中很重要的一个概念，还记得我们之前调用 <code>glVertexAttribPointer()</code> 时将 VBO 绑定到 <code>GL_ARRAY_BUFFER</code> 吗？<strong>在调用 <code>glVertexAttribPointer()</code> 之前绑定的是哪个 VBO，链接的就是它</strong>。</p><blockquote><p>换句话说，调用 <code>glVertexAttribPointer()</code> 时使用的 VBO 是当前被绑定到 <code>GL_ARRAY_BUFFER</code> 上的缓冲区。</p></blockquote><p>我们已经告诉了 OpenGL 该如何解释顶点数据，目前的进度是：</p><ol><li>建立了一批顶点数据存在 vertices 数组里。</li><li>在显存上创建了一个 VBO。</li><li>将顶点数据存在了 VBO 中，GPU 可以通过 VBO 读取顶点数据。</li><li>告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。</li></ol><p>在 OpenGL 中绘制一个物体的准备工作流程大致如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到VBO缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制代码(渲染循环中)</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 渲染一个物体时要使用着色器程序</span></span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// 3. 绘制物体</span></span><br><span class="line">    someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们绘制一个物体的时候都必须重复这一过程，看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体时，绑定正确的缓冲对象，为每个物体配置所有顶点属性就会非常麻烦。有没有一些方法可以使我们<strong>把所有这些状态配置储存在另一个对象中</strong>，并且可以通过绑定这个对象来恢复状态呢？顶点数组对象 VAO 可以完成这项功能。</p><h3 id="顶点数组对象-VAO"><a href="#顶点数组对象-VAO" class="headerlink" title="顶点数组对象 VAO"></a>顶点数组对象 VAO</h3><p><strong>顶点数组对象(Vertex Array Object, VAO)</strong> 可以记录我们对 VBO 内顶点数据的配置，当配置顶点属性指针时，你只需要将之前那些调用执行一次，之后再绘制物体的时候只需要<strong>绑定相应的 VAO</strong> 就行了，这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了，刚刚设置的所有状态都将存储在 VAO 中。</p><p>OpenGL 的核心模式<strong>要求</strong>我们使用 VAO，所以它知道该如何处理我们的顶点输入，如果我们绑定 VAO 失败，OpenGL会拒绝绘制任何东西。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li><code>glEnableVertexAttribArray()</code> 和 <code>glDisableVertexAttribArray()</code> 的调用。</li><li>通过 <code>glVertexAttribPointer()</code> 设置的顶点属性配置。</li><li>通过 <code>glVertexAttribPointer()</code> 调用与顶点属性关联的顶点缓冲对象。</li></ul><p>VBO 和 VAO 的关系如下图：</p><p><img src="/images/posts/opengl/render_pipeline/vao-vbo.png" alt></p><p>所以通常我们是<strong>一个绘制的物体对应一个 VAO</strong>。创建一个VAO和创建一个VBO很类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>要想使用 VAO，只需调用 <code>glBindVertexArray()</code> 绑定VAO。</p><p>从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用，当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。</p><p>这段代码应该看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化代码,只运行一次 (除非你的物体频繁改变)</span></span><br><span class="line"><span class="comment">// 1. 绑定 VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供 OpenGL 使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 绘制代码(渲染循环中)</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 4. 绘制物体</span></span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">    glBindVertexArray(VAO); <span class="comment">//绑定 VAO</span></span><br><span class="line">    someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们打算绘制多个物体，就先要配置每种物体的 VBO 和 VAO ，储存它们供后面使用，绘制物体的时候就拿出相应的 VAO，绑定它，绘制完后再解绑 VAO。</p><p>比如我们需要两种不同的三角形时，首先需要两个三角形的顶点数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创建两个 VAO ，两个 VBO（是不是可以只用一个VBO呢？）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><p>分别设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>渲染：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>释放资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br><span class="line">glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>如果我们打算做渲染的话，现代 OpenGL 需要我们至少设置一个顶点和一个片段着色器，接下来我们先简单介绍一下着色器，然后配置两个非常简单的着色器：<strong>顶点着色器(Vertex Shader)</strong>和<strong>片段着色器(Fragment Shader)</strong>，用来来绘制我们第一个三角形。</p><blockquote><p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 <code>vec.x</code>、<code>vec.y</code>、<code>vec.z</code> 和 <code>vec.w</code> 来获取，注意 <code>vec.w</code> 分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓的透视除法(Perspective Division)上。</p></blockquote><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>还记得上面说的吗？顶点着色器是我们图形渲染管线的第一个部分，<strong>顶点着色器(Vertex Shader)</strong>，它把一个单独的顶点作为输入，顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>我们需要做的第一件事是学习使用<strong>着色器语言 GLSL(OpenGL Shading Language)</strong>编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。和学初级语言时写的 HelloWorld 一样，下面我们先看一段非常简单的顶点着色器的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出 GLSL 看起来很像 C 语言，接下来我们一句句看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br></pre></td></tr></table></figure><p>首先，每个着色器都起始于一个版本声明，OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（比如说 GLSL420 版本对应于 OpenGL4.2），我们这里声明使用 3.30 版本，并且使用核心模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">//声明输入顶点属性</span></span><br></pre></td></tr></table></figure><p>下一步，使用 <code>in</code> 关键字，在顶点着色器中声明所有的<strong>输入顶点属性(Input Vertex Attribute)</strong> 。之前我们用 <code>glVertexAttribPointer()</code> 的第一个参数指定了输入的 location 为 0 ，所以需要通过 <code>layout (location = 0)</code> 设定输入变量的位置值(Location)为 0。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。由于每个顶点都有一个 3D 坐标，我们就创建一个 <code>vec3</code>输入变量 aPos。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// gl_Position的值即为输出</span></span><br></pre></td></tr></table></figure><p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 <code>gl_Position</code> 变量（<code>vec4</code>类型）。在 <code>main</code> 函数里，<code>gl_Position</code> 最后的值就是该顶点着色器的<strong>输出</strong>。</p><p>由于我们的输入是一个 3 分量的向量，我们必须把它转换为 <code>gl_Position</code> 所对应的 4 分量的向量。我们可以把 <code>vec3</code> 的数据作为 <code>vec4</code> 构造器的参数，同时把 <code>w</code> 分量设置为 1.0f（后面解释为什么）。</p><p>很简单，就这样写完了，再看一次我们这个顶点着色器的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了（在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内，但是现在我们可以先不考虑）。</p><h4 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h4><p>我们已经写了一个顶点着色器源码，但是为了能够让 OpenGL 使用它，我们必须在<strong>运行时动态编译它的源码</strong>，我们写的顶点着色器源码将储存在一个 C 的字符串中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br></pre></td></tr></table></figure><p>(很恶心，但我们之后会通过文件读写解决这个问题的，不用着急)</p><p>我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的，所以我们储存这个顶点着色器的 ID 为 <code>unsigned int</code>，然后用 <code>glCreateShader</code> 创建这个着色器，我们把需要创建的着色器类型以参数形式提供给<br><code>glCreateShader</code>，由于我们正在创建一个顶点着色器，传递的参数是 <code>GL_VERTEX_SHADER</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(</span><br><span class="line">    vertexShader,        <span class="comment">//要编译的着色器对象</span></span><br><span class="line">    <span class="number">1</span>,                   <span class="comment">//传递的源码字符串数量</span></span><br><span class="line">    &amp;vertexShaderSource, <span class="comment">//顶点着色器源码</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource()</code> 函数的参数：</p><ol><li>第一个参数是要编译的着色器对象。</li><li>第二参数指定了传递的源码字符串数量，这里只有一个。</li><li>第三个参数是顶点着色器源码。</li><li>第四个参数我们先设置为 <code>NULL</code>。</li></ol><p>同时，我们希望检测在调用 <code>glCompileShader</code> 后编译是否成功了，如果没成功的话，也希望知道错误是什么，这样才能方便修复它们，检测编译时错误输出可以通过以下代码来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> success;        <span class="comment">//是否成功编译</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];  <span class="comment">//储存错误消息</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);   <span class="comment">//检查是否编译成功</span></span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义一个整型变量 <code>success</code> 来表示是否成功编译，还定义了一个储存错误消息（出错了才会有）的容器 <code>infoLog[]</code> ，这是个 char 类型的数组，然后我们用 <code>glGetShaderiv</code> 函数检查是否编译成功，如果编译失败，我们会用 <code>glGetShaderInfoLog()</code> 获取错误消息，然后打印它。如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>我们刚才通过顶点着色器的 <code>gl_Position</code> 变量设置了三角形三个点的位置，现在我们要在片段着色器里设置他们的颜色。</p><p><strong>片段着色器(Fragment Shader)</strong>的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方，通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可被用来计算最终像素的颜色。</p><p>在计算机图形中颜色被表示为有 4 个元素的数组：<strong>红色、绿色、蓝色和alpha(透明度)分量</strong>，通常缩写为 RGBA。当在 OpenGL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色。</p><p>现在看到我们的片段着色器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;<span class="comment">//只需要一个输出变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们可以用 out 关键字声明输出变量，这里我们命名为 <code>FragColor</code>。我们将一个 alpha 值为 1.0（代表完全不透明）的橘黄色的 vec4 赋值给颜色输出 <code>FragColor</code>。</p><h4 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h4><p>编译片段着色器的过程与顶点着色器类似，不过我们使用 <code>GL_FRAGMENT_SHADER</code> 常量作为着色器类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>我们同样用刚才的方法检测编译是否出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> success;<span class="comment">//是否成功编译</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];<span class="comment">//储存错误消息</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有检测到任何错误，片段着色器也被编译成功了。好了，现在两个着色器现在都编译了，总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//build and compile 着色器程序（main内）</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">        <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">        <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们要把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本，如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入，如果输出和输入不匹配，就会得到一个连接错误。</p><p>创建一个程序对象很简单，像刚才一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure><p><code>glCreateProgram()</code> 函数创建一个程序，并返回新创建程序对象的 ID 引用。</p><p>现在我们需要把之前编译的着色器附加到程序对象上，然后用 <code>glLinkProgram()</code> 链接它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用 <code>glLinkProgram()</code> 链接。</p><p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志</p><p>与上面不同，我们尝试不调用 <code>glGetShaderiv()</code> 和 <code>glGetShaderInfoLog()</code>，而是使用 <code>glGetProgramiv()</code> 和 <code>glGetProgramInfoLog()</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果着色器程序没有报错，我们通过 <code>glLinkProgram()</code> 得到的就是一个程序对象，我们可以调用 <code>glUseProgram()</code> 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);    <span class="comment">//写进渲染循环</span></span><br></pre></td></tr></table></figure><p>在 <code>glUseProgram()</code> 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器）了。</p><p>对了，<strong>在把着色器对象链接到程序对象以后，记得删除着色器对象</strong>，我们不再需要它们了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><h2 id="画出三角形"><a href="#画出三角形" class="headerlink" title="画出三角形"></a>画出三角形</h2><p>庆贺吧，终于来到了这一刻。</p><p>要想绘制我们想要的物体，OpenGL 给我们提供了 <code>glDrawArrays()</code> 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(</span><br><span class="line">    GL_TRIANGLES,   <span class="comment">//图元的类型</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">//顶点数组的起始索引</span></span><br><span class="line">    <span class="number">3</span>               <span class="comment">//绘制多少个顶点</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glDrawArrays()</code> 函数：</p><ol><li>第一个参数是我们打算绘制的 OpenGL 图元的类型，由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES 给它。</li><li>第二个参数指定了顶点数组的起始索引，我们这里填 0 。</li><li>最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</li></ol><p>现在尝试编译代码，如果编译通过了，你应该看到下面的结果：</p><p><img src="/images/posts/opengl/render_pipeline/result.png" alt></p><p>这时候我们的代码是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定VAO</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h2><p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西——<strong>索引缓冲对象</strong>(Element Buffer Object，<strong>EBO</strong>，也叫Index Buffer Object，IBO)</p><p>假设我们不再绘制一个三角形而是绘制一个矩形，我们可以<strong>绘制两个三角形来组成一个矩形</strong>（OpenGL 主要处理三角形）这会生成下面的顶点的集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了：我们指定了右下角和左上角两次，一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。更好的解决方案是只储存不同的顶点，并<strong>设定绘制这些顶点的顺序</strong>，这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。</p><p><strong>索引缓冲对象 EBO</strong> 就是干这个的，和顶点缓冲对象一样，EBO 也是一个缓冲，它<strong>专门储存索引</strong>，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。</p><p>首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 0号点</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1号点</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 2号点</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 3号点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了 4 个顶点，下一步我们需要创建索引缓冲对象，与 VBO 类似，我们先绑定 EBO 然后用 <code>glBufferData()</code> 把索引复制到缓冲里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p>同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为 <code>GL_ELEMENT_ARRAY_BUFFER</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了 <code>GL_ELEMENT_ARRAY_BUFFER</code> 当作缓冲目标。</p><p>最后一件要做的事是用 <code>glDrawElements()</code> 来替换 <code>glDrawArrays()</code> 函数，来指明我们从索引缓冲渲染。使用 <code>glDrawElements()</code> 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line">glDrawElements(</span><br><span class="line">    GL_TRIANGLES,      <span class="comment">//绘制的模式</span></span><br><span class="line">    <span class="number">6</span>,                 <span class="comment">//绘制顶点的个数</span></span><br><span class="line">    GL_UNSIGNED_INT,   <span class="comment">//索引的类型</span></span><br><span class="line">    <span class="number">0</span>                  <span class="comment">//偏移量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glDrawElements</code> 的参数：</p><ol><li>第一个参数指定了我们绘制的模式，这个和 <code>glDrawArrays()</code> 的一样。</li><li>第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。</li><li>第三个参数是索引的类型，这里是 <code>GL_UNSIGNED_INT</code>。</li><li>最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0 。</li></ol><p><code>glDrawElements()</code> 函数从当前绑定到 <code>GL_ELEMENT_ARRAY_BUFFER</code> 目标的 EBO 中获取索引，这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态，VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象，<strong>绑定 VAO 的同时也会自动绑定 EBO</strong>。</p><p><img src="/images/posts/opengl/render_pipeline/vao-ebo.png" alt></p><p>当目标是 <code>GL_ELEMENT_ARRAY_BUFFER</code> 的时候，VAO 会储存 <code>glBindBuffer()</code> 的函数调用，这也意味着它也会储存解绑调用，所以确保你没有在解绑 VAO 之前解绑索引数组缓冲，否则它就没有这个 EBO 配置了最后的初始化和绘制代码现在看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化代码</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .绘制代码（渲染循环中）</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)；</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result2.png" alt></p><h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="线框模式-Wireframe-Mode"><a href="#线框模式-Wireframe-Mode" class="headerlink" title="线框模式(Wireframe Mode)"></a>线框模式(Wireframe Mode)</h3><p>要想用线框模式绘制你的三角形，你可以通过 <code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code> 函数配置 OpenGL 如何绘制图元。</p><ol><li>第一个参数表示我们打算将其应用到所有的三角形的正面和背面。</li><li>第二个参数告诉我们用线来绘制。</li></ol><p><strong>设定之后的绘制调用会一直以线框模式绘制三角形</strong>，直到我们用 <code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code> 将其设置回默认模式。</p><p><img src="/images/posts/opengl/render_pipeline/result3.png" alt></p><p>可以看到这个矩形的确是由两个三角形组成的，完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 0号点</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1号点</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 2号点</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 3号点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线框模式wireframe</span></span><br><span class="line">    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个彼此相连的三角形"><a href="#两个彼此相连的三角形" class="headerlink" title="两个彼此相连的三角形"></a>两个彼此相连的三角形</h3><p>我们可以尝试添加更多顶点到数据中，使用 <code>glDrawArrays()</code>，绘制两个彼此相连的三角形。我们只需要更改顶点数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//第一个三角形</span></span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    <span class="comment">//第二个三角形</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后更改 EBO 设置（直接注了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line"><span class="comment">// glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br></pre></td></tr></table></figure><p>更改渲染指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result4.png" alt></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">//第一个三角形</span></span><br><span class="line">        <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">        <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">        <span class="comment">//第二个三角形</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以用上 EBO，更简单，我们需要这样改下顶点数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EBO设置和上文相同，结果是一样的。</p><h3 id="使用不同的-VAO-和-VBO"><a href="#使用不同的-VAO-和-VBO" class="headerlink" title="使用不同的 VAO 和 VBO"></a>使用不同的 VAO 和 VBO</h3><p>效果和之前是相同的，但是我们分别创建了两个不同的 VAO 和两个不同的 VBO，所以顶点数据也要分成两个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>VAO，VBO 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsigned int VBO;</span></span><br><span class="line"><span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="comment">//unsigned int VAO;</span></span><br><span class="line"><span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="comment">//unsigned int EBO;</span></span><br><span class="line"><span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 初始化代码</span></span><br><span class="line"><span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line"><span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line"><span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line"><span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line"><span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line"><span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line"><span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>渲染指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line"><span class="comment">//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>释放资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><p>全部源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    -0.9f, -0.5f, 0.0f,  // left </span></span><br><span class="line">    <span class="comment">//    -0.0f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    -0.45f, 0.5f, 0.0f,  // top </span></span><br><span class="line">    <span class="comment">//    0.9f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    0.45f, 0.5f, 0.0f   // top </span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 2, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 3, 4  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unsigned int VBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//unsigned int VAO;</span></span><br><span class="line">    <span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//unsigned int EBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">    glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 初始化代码</span></span><br><span class="line">    <span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">    <span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line">    <span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line">    <span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">        <span class="comment">//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建两个着色器程序"><a href="#创建两个着色器程序" class="headerlink" title="创建两个着色器程序"></a>创建两个着色器程序</h3><p>第二个程序使用一个不同的片段着色器(顶点着色器无需改动)，再次绘制这两个三角形，让其中一个输出为黄色。结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result5.png" alt></p><p>修改着色器程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="comment">//const char *fragmentShaderSource = "#version 330 core\n"</span></span><br><span class="line"><span class="comment">//"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="comment">//"void main()\n"</span></span><br><span class="line"><span class="comment">//"&#123;\n"</span></span><br><span class="line"><span class="comment">//"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="comment">//"&#125;\n\0";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShader1Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShader2Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure><p>参考源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="comment">//const char *fragmentShaderSource = "#version 330 core\n"</span></span><br><span class="line"><span class="comment">//"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="comment">//"void main()\n"</span></span><br><span class="line"><span class="comment">//"&#123;\n"</span></span><br><span class="line"><span class="comment">//"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="comment">//"&#125;\n\0";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShader1Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShader2Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="comment">//unsigned int fragmentShader;</span></span><br><span class="line">    <span class="comment">//fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span></span><br><span class="line">    <span class="comment">//glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span></span><br><span class="line">    <span class="comment">//glCompileShader(fragmentShader);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShaderOrange;</span><br><span class="line">    fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShaderYellow;</span><br><span class="line">    fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShaderOrange, <span class="number">1</span>, &amp;fragmentShader1Source, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShaderOrange);</span><br><span class="line">    glShaderSource(fragmentShaderYellow, <span class="number">1</span>, &amp;fragmentShader2Source, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShaderYellow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    <span class="comment">//glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span></span><br><span class="line">    <span class="comment">//if (!success) &#123;</span></span><br><span class="line">    <span class="comment">//    glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "fragmentShader complie SUCCESS" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    glGetShaderiv(fragmentShaderOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShaderOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShaderOrange complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glGetShaderiv(fragmentShaderYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShaderYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShaderYellow complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="comment">//unsigned int shaderProgram;</span></span><br><span class="line">    <span class="comment">//shaderProgram = glCreateProgram();</span></span><br><span class="line">    <span class="comment">//glAttachShader(shaderProgram, vertexShader);</span></span><br><span class="line">    <span class="comment">//glAttachShader(shaderProgram, fragmentShader);</span></span><br><span class="line">    <span class="comment">//glLinkProgram(shaderProgram);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgramOrange;</span><br><span class="line">    shaderProgramOrange = glCreateProgram();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgramYellow;</span><br><span class="line">    shaderProgramYellow = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class="line">    glLinkProgram(shaderProgramOrange);</span><br><span class="line">    glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class="line">    glLinkProgram(shaderProgramYellow);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    <span class="comment">//glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span></span><br><span class="line">    <span class="comment">//if (!success) &#123;</span></span><br><span class="line">    <span class="comment">//    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "shaderProgram complie SUCCESS" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgramOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgramOrange complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgramYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgramYellow complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    <span class="comment">//glDeleteShader(fragmentShader);</span></span><br><span class="line">    glDeleteShader(fragmentShaderOrange);</span><br><span class="line">    glDeleteShader(fragmentShaderYellow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    -0.9f, -0.5f, 0.0f,  // left </span></span><br><span class="line">    <span class="comment">//    -0.0f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    -0.45f, 0.5f, 0.0f,  // top </span></span><br><span class="line">    <span class="comment">//    0.9f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    0.45f, 0.5f, 0.0f   // top </span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 2, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 3, 4  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unsigned int VBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//unsigned int VAO;</span></span><br><span class="line">    <span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//unsigned int EBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">    glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 初始化代码</span></span><br><span class="line">    <span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">    <span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line">    <span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line">    <span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//glUseProgram(shaderProgram);</span></span><br><span class="line">        <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">        <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgramOrange);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgramYellow);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://learnopengl-cn.readthedocs.io/zh/latest/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习 OpenGL 渲染特效的东西，需要补充一些基础知识，遇到不错的介绍文章，整理摘录。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://murphypei.github.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="https://murphypei.github.io/tags/OpenGL/"/>
    
      <category term="渲染" scheme="https://murphypei.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="render" scheme="https://murphypei.github.io/tags/render/"/>
    
      <category term="shader" scheme="https://murphypei.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>Python.h: No such file or directory</title>
    <link href="https://murphypei.github.io//blog/2020/12/apt-error.html"/>
    <id>https://murphypei.github.io//blog/2020/12/apt-error.html</id>
    <published>2020-12-14T08:59:34.000Z</published>
    <updated>2021-02-20T03:36:02.780Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用 pip 安装的时候遇到了一个关于 <code>Python.h</code> 和 <code>apt_pkg</code> 的错误。在我的印象中这个错误挺常见的，所以记录一下解决方案。</p><a id="more"></a><p>通过 pip 安装一些包，比如 psutil，会报一个比较常见的错误：</p><ul><li><code>psutil/_psutil_common.c:9:20: fatal error: Python.h: No such file or directory</code></li></ul><p>这个错误主要是 <code>python-dev</code> 这个包没安装到位。比如 ubuntu18.04 自带的是 python3.6。如果你安装了 python3.7，设置不到位，就会导致这个错误。常见的解决办法就是: <code>sudo apt install -fy python3.7-dev</code>。</p><p>在解决这个问题的时候发现另一个问题，<code>add-apt-repository</code> 错误：</p><ul><li><code>ModuleNotFoundError: No module named &#39;apt_pkg&#39;</code></li></ul><p>主要原因是系统默认的是 python3.5，当前运行环境中的 python3 不是 python3.5。导致一些运行时库连接错误。解决办法（python3.7 为例）：</p><p><code>sudo cp /usr/lib/python3/dist-packages/apt_pkg.cpython-35m-x86_64-linux-gnu.so /usr/lib/python3/dist-packages/apt_pkg.cpython-37m-x86_64-linux-gnu.so</code></p><p>总之上述错误多半都是由于修改了系统默认自带的 python 导致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用 pip 安装的时候遇到了一个关于 &lt;code&gt;Python.h&lt;/code&gt; 和 &lt;code&gt;apt_pkg&lt;/code&gt; 的错误。在我的印象中这个错误挺常见的，所以记录一下解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="apt" scheme="https://murphypei.github.io/tags/apt/"/>
    
      <category term="Python.h" scheme="https://murphypei.github.io/tags/Python-h/"/>
    
      <category term="apt-pkg" scheme="https://murphypei.github.io/tags/apt-pkg/"/>
    
  </entry>
  
  <entry>
    <title>目标检测中 Anchor 与 Loss 计算的梳理</title>
    <link href="https://murphypei.github.io//blog/2020/10/anchor-loss.html"/>
    <id>https://murphypei.github.io//blog/2020/10/anchor-loss.html</id>
    <published>2020-10-19T08:59:34.000Z</published>
    <updated>2021-02-20T03:29:18.110Z</updated>
    
    <content type="html"><![CDATA[<p>anchor 是一类目标检测方法种的一个核心概念，其本质是一个预设的框，但是这个框也为 loss 计算带来一些麻烦。</p><a id="more"></a><p>对于一般的目标检测 loss 计算，通常分为几部分。比如 yolo 系列分为 objectness（是否包含目标）、classification（目标分类）、boundingbox-regression（目标位置）。其中，每个样本都需要计算 objectness 得分的损失，正样本需要计算 classification 和 bbox-regression 损失，其中每种损失又有不同的计算方式和组合方法，比如 bbox-regression 有 D_IoU、G_IoU、C_IoU 等等，组合方法有 Focal Loss 等等。但是这些不是我们这篇文章关注的重点。</p><p>对于目标检测我们要搞明白一个核心问题：<strong>如何生成参与 loss 计算的样本</strong>？anchor 和 ground-truth 的纠缠不休就是在这个问题上，各种框混杂一起。要搞明白这个问题，我们把带 anchor 的目标检测中出现各种框的核心概念一一剥开。</p><p>一般来说，带 anchor 的目标检测包含以下几种框：</p><ol><li>ground-truth，简称 gt，标注生成的框，包含位置信息和类别信息。</li><li>anchor，也成为先验框，尺寸预先设置好的框，一般在 feature map 上，每个像素点（也称为 cell）有多个，每个大小形状都不一样。可以通过 k-means 等方法生成适合数据集的尺寸，同时大小不同的尺寸也和模型的多个检测分支对应。</li><li>predict，也称为预测框，网络的 detect 层的输出信息，大小通常是 [n, h, w, (nc + 4 + 1)]，n 表示 feature map 上每 cell 的 anchor 数量，h 和 w 是 feature map 的大小，nc 表示类别得分，4 表示位置信息，1 表示 objectness 得分。</li></ol><p>写的越多越杂乱，所以不写太多计算，只要记住这些核心概念，下面来说明每种框之间的关联：</p><ol><li>anchor 和 gt 相互作用，通过筛选手段，确定哪个 anchor 负责预测哪个 gt，不同检测方法中筛选手段不同，并且有的规定一个 gt 必须有一个 anchor 负责预测，有的则选择忽略某些 gt，有的一个 gt 可以有多个 anchor 对应。</li><li>predict 和 anchor 一一对应。首先可以明确，每个 predict 都是对应一个 anchor 的（其实现在大部分检测方法比如 yolo，predict 输出的并不是实际坐标，需要通过 anchor 解码）。当 1 中确定某个 anchor 有负责预测 gt 之后，这个 anchor 对应的 predicts 就是正样本，其余就是负样本。predicts 的输出结果和 gt 相互作用，计算 loss。</li></ol><p>总结以上核心：<strong>正负样本通常由 gt 和先验框 anchor 匹配生成，参与计算的是 anchor 的和 gt（只有尺寸，没有类别），而计算 loss 则是其对应的 predict 和 gt（包含类别信息）</strong>。这句话就点明了 3 种框的关系，可以看出 anchor 是桥梁，非常重要。</p><p>有了以上概念，我们来实际操作解读以下经典的目标检测中一些具体实际操作。</p><h3 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h3><p>我的老朋友，最爱。faster-rcnn 属于 two-stage，anchor 主要是在第一层 RPN 中用到。我们知道 RPN 用于生成 RoI。我们把 RPN 网络输出的就是 predicts，那么如何计算 Loss 呢？</p><p>依据上述步骤，首先就是 anchor 和 gt 的匹配。在 faster-rcnn 中分为：</p><ol><li>初始化每个 anchor 的 mask  为 -1，-1 表示这个 anchor 被忽略，不参与 loss 计算。</li><li>计算每个 gt 和 每个 anchor 的 iou。</li><li>对于一个 anchor，如果其和所有 gt 的 iou 都小于阈值 neg_iou_thr，则标记为负样本，mask 设为 0；如果最大 iou 大于阈值 pos_iou_thr，则标记为正样本。此时有一些 gt 是没有 anchor 负责预测的，这一步的意思是挑选优质的正样本和负样本。</li><li>对于所有 gt，如果其和某个 anchor 的 iou 大于阈值 min_pos_iou，则也将这些 anchor 标记为正样本，min_pos_ios &lt;= pos_iou_thr。这一步是为了增加正样本的数量（如果不需要增加正样本数量，则可以设置只和最大 iou 的 anchor 匹配），一个 gt 可能会由多个 anchor 负责预测。通过本步骤，可以最大程度保证每个 gt 都有 anchor 负责预测，<strong>如果还是小于 min_pos_iou，那就没办法了，这个 gt 被忽略了</strong>。这一步引入的 anchor 因为 iou 较少，质量较低。</li></ol><p>上述规则将 anchor 标记分类（anchor_target_layer 实现），正样本都有对应的 gt 用于计算 bbox-regression 损失，同时正负样本本身又可以用于计算 objectness loss，直接将每个 anchor 对应的 predict 带入计算即可。没有用到的 anchor（标记为 -1），计算 loss 的时候被忽略。另外，RPN 没有 classification 损失。</p><h3 id="YOLO-V2-V3"><a href="#YOLO-V2-V3" class="headerlink" title="YOLO V2/V3"></a>YOLO V2/V3</h3><p>one-stage 最爱。废话少说，yolo v2 步骤如下：</p><ol><li>初始化，标记所有 anchor 为负样本。</li><li>对于一个 gt，确定其中心落在哪个 cell，计算该 cell 的所有 anchor 与这个 gt 的 iou，取最大值，这个 anchor 标记为正样本，负责预测该 gt。<strong>这一步计算 iou 时只考虑形状，不考虑框的位置</strong>。具体做法就是将 anchor 和 gt 这两个框的左上角对齐，然后计算 iou。这一步还隐含一个假设，多个 gt 不会落到同一个 cell 中。</li><li>如果一个 anchor 经过 1 被标记为负样本，但是其与某个 gt 的 iou 大于某个阈值（0.6），则将其标记为忽略（低质量的负样本）。这里需要注意，<strong>yolo v2/v3 中这一步计算使用的是 anchor 预测值，而不是预设的 anchor</strong>。</li></ol><p>区分了正负样本之后就可以用于计算 loss 了，类似 faster-rcnn。</p><p>我参考了这篇<a href="https://zhuanlan.zhihu.com/p/35325884" target="_blank" rel="noopener">YOLOv2原理与实现</a>，上述原理在代码中实现是倒过来的，同时在开始时还有计算 predict 和 anchor  的位置偏移，这个能够加快 predict 的形状向 anchor 的形状收敛。因为 yolo 中的 anchor 是聚合而来，本身就比较合理。仔细看下面的 loss 计算公式：</p><p><img src="/images/posts/dl/anchor/yolov2_loss.jpg" alt></p><ol><li>求和公式中 W H A 分别表示 feature map 的长、宽以及每个 cell 的 anchor 数量。</li><li>第一项是负样本，只计算 objectness 的置信度误差。</li><li>第二项是 anchor 先验框和预测框的坐标误差，只计算前 12800 个迭代，加速预测框向先验框的收敛。</li><li>第三项是正样本，其中又包含三项：<ol><li>第一项是预测框与 gt 的坐标误差（coord）；</li><li>第二项是是 objectness 置信度误差（obj）；</li><li>第三项是分类误差。</li></ol></li></ol><p>上述公式弄明白了，也就基本理解了各种框的用途和意义了。v3 和 v2 一样是基于 max iou 的匹配规则，只不过有多个检测分支，其规定一个 gt 不可能出现在多个检测分支上，也就是每个 gt 取三个检测分支上 anchor 匹配最大的那个。</p><h3 id="YOLO-V5"><a href="#YOLO-V5" class="headerlink" title="YOLO V5"></a>YOLO V5</h3><p>yolo v5 相对 v2/v3 变动很大，主要是匹配规则变了，首先明确一点，v5 和 v3 一样，同样有 3 个检测分支，但是v5 中的匹配是逐层进行的，每一层互不影响，也就是说一个 gt 可以与多个检测层的 anchor 匹配。具体规则如下（以下规则是逐层进行的）：</p><ol><li>对于一个 gt，计算其与当前层的 anchor 是否匹配，匹配是通过 shape 而不是 iou。以 h 为例，就是 gt_h/anchor_h 要大于一个 1/anchor_t，小于 anchor_t，anchor_t 默认设置为 4.0。w 同理。如果不匹配，则说明该 gt 和 anchor 匹配度不够，<strong>在当前层的检测中舍弃掉这个 gt</strong>。因此在检测小目标的 detect 层，比如下采样为 8 的 P3 层，一个大目标 gt 可能会被舍弃，认为是背景。</li><li>对于剩余 gt，计算其中心落在哪个 cell 中，同时利用四舍五入方法，找出最近的两个 cell，认为这 3 个 cell 都负责预测这个 gt。很明显，通过这种方法，正样本的数量将明显增多。<ol><li>一个 cell 相邻的有上下左右 4 个cell，根据中心点在当前 cell 中的偏移来找出和中心点比较近的两个相邻 cell。</li></ol></li></ol><p><img src="/images/posts/dl/anchor/yolov5_near_cell.jpg" alt></p><p>代码中的具体做法是：在任何一预测层，将每个 gt 复制和 anchor 个数一样多的数目（3个），然后将 gt 和 anchor 一一对应计算，去除本层不匹配的 gt，然后对 gt 原始中心点网格坐标扩展两个邻居像素，因此每个 gt 总共有 3 个 cell 上的若干个 anchor 负责预测。有个细节需要注意，前面 shape 过滤时候是不考虑 xy 坐标的，也就是说 gt 的 wh 是和所有 anchor 匹配的，会导致找到的邻居也相当于进行了 shape 过滤规则。详见 <code>build_targets</code> 函数，可以参考解析：<a href="https://zhuanlan.zhihu.com/p/183838757" target="_blank" rel="noopener">yolov5深度可视化解析</a> 。</p><p>yolo v5 的改动造成的变化主要如下：</p><ol><li>不同于 yolov3 和 v4，其 gt 可以跨层预测，即有些 gt 在多个预测层都算正样本。</li><li>不同于 yolov3 和 v4，其 gt 匹配数范围扩大，明显增加了很多正样本。（但是引入了很多低质量的负样本）</li><li>不同于 yolov3 和 v4，有些 gt 由于和 anchor 匹配度不高，而变成背景。</li></ol><p>有了正负样本，v5 的 loss 计算也很简单，classification 和 objectness confidence 分支都是 bce loss，bbox regression 直接采用 giou loss。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;anchor 是一类目标检测方法种的一个核心概念，其本质是一个预设的框，但是这个框也为 loss 计算带来一些麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="梯度消失" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="ReLU" scheme="https://murphypei.github.io/tags/ReLU/"/>
    
      <category term="LeakyReLU" scheme="https://murphypei.github.io/tags/LeakyReLU/"/>
    
      <category term="激活函数" scheme="https://murphypei.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ReLU 激活函数中神经元死亡问题</title>
    <link href="https://murphypei.github.io//blog/2020/09/relu-dying.html"/>
    <id>https://murphypei.github.io//blog/2020/09/relu-dying.html</id>
    <published>2020-09-25T08:59:34.000Z</published>
    <updated>2021-02-20T03:29:21.270Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 MobileNetV3 的结构特征，又碰到了新的激活函数，查看了其与 ReLU 的联系，联想到之前看到过的 ReLU 的问题，做个记录。</p><a id="more"></a><p>ReLU 激活函数可以算作是深度学习领域的 GOAT 了，虽然现在出现了很多变种和发展，但是综合使用范围和效果，其当之无愧。ReLU 之所以能获得广泛认可和应用，离不开自身的特性（图我就不画了）。</p><ol><li>单侧抑制。当输入小于 0 时，神经元处于抑制状态，也就是输出为 0。</li><li>宽阔的激活边界。当输入大于 0 时，神经元全部出于激活状态，激活值取值边界无穷大，无饱和区。<ol><li>Sigmoid 存在梯度小时问题，就是因为当出于饱和区时，导数趋近于 0，更新缓慢，拖累收敛。</li><li>另一方面，Sigmoid 这类激活函数的导数绝对值小于 1，链式法则的情况下在连乘的时候很容易迅速变小为接近于 0，也是导致梯度消失的原因。</li></ol></li><li>稀疏性。相比于 Sigmoid 之类的激活函数，稀疏性是 ReLU 的优势。Sigmoid 把抑制区设置为一个极小值，但是不为 0，因此要参与运算，而 ReLU 的抑制区的结果直接为 0，不参与后续计算，简单粗暴的造成网络稀疏性，而且计算十分简单。<ol><li>稀疏性和单侧抑制有很多生物神经学上的解释，对于大多数深度学习从业者而言，其计算简单和对网络稀疏性（防止过拟合）的优点才是真正关注的。</li></ol></li></ol><p>ReLU 凭借上述优点获得了无数青睐，但是也不能忽视其存在的不足，甚至一些不足就是由于其自身特性带来的。比如最常见的 ReLU Dying 问题。</p><p><strong>ReLU Dying 问题是指当出现异常输入时，在反向传播中会产生大的梯度，这种大的梯度会导致神经元死亡和梯度消失</strong>。等等，ReLU 不就是为了解决梯度消失的问题吗？我们提取这里的关键词，异常输入，大梯度，神经元死亡，一一解释。</p><p><img src="/images/posts/dl/relu/neural_cell.jpg" alt></p><p>上图是一个典型的神经元。</p><p>现在假设，这个神经元已经经过若干次迭代，其参数 $(\vec w, b)$ 已经迭代得趋于稳定。现在，神经元接收到了一个<strong>异常输入</strong> $\vec x$。比方说，它的某一维特征 $x_i$ 与对应的权重 $w_i$ 的乘积 $w_ix_i$ 非常大。一般来说，这意味着 $x_i$ 的绝对值非常大。于是，ReLU 的输入就会很大，对应 ReLU 的输出 $y$ 也就会很大。好了，假设这个 ReLU 神经元期望的输出（ground truth）是 $\hat y$，这个时候损失就会很大——损失一般是 $\lvert y - \hat y\rvert$ 的增函数，记为 $f\bigl(\lvert y - \hat y\rvert\bigr)$。</p><p>于是，在反向传播过程中，传递到 ReLU 的输入时的梯度就是 $g = f\bigl(\lvert y - \hat y\rvert\bigr)$ 。考虑对于偏置 $b$ 有更新：</p><script type="math/tex; mode=display">g = f\bigl(\lvert y - \hat y\rvert\bigr)</script><p>考虑到<strong>大梯度</strong> $g$ 是一个很大的正数，于是 $b$ 可能被更新为一个很小的负数。此后，对于常规输入来说，ReLU 的输入大概率是个负数。这也就是说，ReLU 大概率是关闭的。这时，梯度无法经 ReLU 反向传播至 ReLU 的输入函数。也就是说，这个神经元的参数再也不会更新了。这就是所谓的<strong>神经元死亡</strong>。</p><p>如此看来，尽管 ReLU 解决了因激活函数导数的绝对值小于 1，在反向传播连乘的过程中迅速变小消失至 0 的问题，但<strong>由于它在输入为负的区段导数恒为零，而使得它对异常值特别敏感</strong>。这种异常值可能会使 ReLU 永久关闭，而杀死神经元。</p><p>由此可见，神经网络中的梯度消失问题是个多元化的问题，不仅仅局限于由于激活函数导数连乘导致的梯度消失。</p><p>话说回来，很多激活函数比如 LeakyReLU 把小于 0 的输入的输出不设为 0，从而缓解这个问题，其实现在这个问题已经被 BN 解决了。回到上述我们分析的原因，导致 ReLU Dying 的前提是异常输入，如果 Conv-BN-ReLU 这种结构，由于 BN 的归一化操作，异常输入基本不存在了，所以这个问题也被解决了，这也是目前 ReLU 仍然流行使用的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 MobileNetV3 的结构特征，又碰到了新的激活函数，查看了其与 ReLU 的联系，联想到之前看到过的 ReLU 的问题，做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="梯度消失" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="ReLU" scheme="https://murphypei.github.io/tags/ReLU/"/>
    
      <category term="LeakyReLU" scheme="https://murphypei.github.io/tags/LeakyReLU/"/>
    
      <category term="激活函数" scheme="https://murphypei.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch 多进程分布式训练实战</title>
    <link href="https://murphypei.github.io//blog/2020/09/pytorch-distributed.html"/>
    <id>https://murphypei.github.io//blog/2020/09/pytorch-distributed.html</id>
    <published>2020-09-24T08:02:34.000Z</published>
    <updated>2021-02-20T03:28:31.970Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch 可以通过 <code>torch.nn.DataParallel</code> 直接切分数据并行在单机多卡上，实践证明这个接口并行力度并不尽如人意，主要问题在于数据在 master 上处理然后下发到其他 slaver 上训练，而且由于 <a href="https://murphypei.github.io/blog/2017/05/python-GIL">GIL</a> 的存在只有计算是并行的。<code>torch.distributed</code> 提供了更好的接口和并行方式，搭配多进程接口 <code>torch.multiprocessing</code> 可以提供更加高效的并行训练。</p><a id="more"></a><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>我们都知道由于 GIL 的存在， python 要想真正的并行必须使用多进程，IO 频繁可以勉强使用多线程。<code>torch.nn.DataParallel</code> 全局只有一个进程，受到了 GIL 的限制，所以肯定会拖累并行的力度。</p><p>python 自带的 <code>multiprocessing</code> 是多进程常用的实现，但是有一个巨大的问题，<strong>不支持 CUDA</strong>，所以我们使用 GPU 训练的时候不能用这个包，需要使用 PyTorch 提供的 <code>torch.multiprocessing</code>。它提供了和 <code>multiprocessing</code> 几乎一样的接口，所以用起来也比较方便。</p><p>这里额外插一句，<code>torch.distributed</code> 可以通过 <code>torch.distributed.launch</code> 启动多卡训练，但是我个人的原则是能交由自己代码控制的都不会交给工具，所以使用 <code>torch.multiprocessing</code> 手动提交多进程并行。所以本文不会对 <code>torch.distributed.launch</code> 以及多级多卡这类我没测试使用过的东西做说明。</p><h3 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h3><p><code>torch.distributed</code> 提供了和通用分布式系统常见的类似概念。</p><ul><li><strong>group</strong>：进程组。默认情况下，只有一个组，一个 <code>job</code> 即为一个组，也即一个 <code>world</code>，当我们使用多进程的时候，一个 <code>group</code> 就有了多个 <code>world</code>。当需要进行更加精细的通信时，可以通过 <code>new_group</code> 接口，使用 word 的子集，创建新组，用于集体通信等。</li><li><strong>world</strong>：全局进程个数。</li><li><strong>rank</strong>：表示进程序号，用于进程间通信，可以用于表示进程的优先级。我们一般设置 <code>rank=0</code> 的主机为 master 节点。</li><li><strong>local_rank</strong>：进程内 GPU 编号，非显式参数，由 <code>torch.distributed.launch</code> 内部指定。比方说， <code>rank=3</code>，<code>local_rank=0</code> 表示第 3 个进程内的第 1 块 GPU。</li></ul><h3 id="PyTorch-多进程分布式训练实战"><a href="#PyTorch-多进程分布式训练实战" class="headerlink" title="PyTorch 多进程分布式训练实战"></a>PyTorch 多进程分布式训练实战</h3><h5 id="启动多进程任务："><a href="#启动多进程任务：" class="headerlink" title="启动多进程任务："></a>启动多进程任务：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ngpus_per_node = torch.cuda.device_count()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> torch.cuda.is_available():</span><br><span class="line">        print(<span class="string">"\033[1;33m&#123;&#125;\033[0m"</span>.format(<span class="string">"gpu is not available, cpu will be very slow!"</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Let's use &#123;&#125; GPUs!"</span>.format(torch.cuda.device_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        random.seed(args.seed)</span><br><span class="line">        torch.manual_seed(args.seed)</span><br><span class="line">        cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">"\033[1;33m&#123;&#125;\033[0m"</span>.format(</span><br><span class="line">            (<span class="string">"You have chosen to seed training. This will turn on the CUDNN deterministic setting, which can slow down "</span></span><br><span class="line">             <span class="string">"your training considerably! You may see unexpected behavior when restarting from checkpoints."</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.dist_url == <span class="string">"env://"</span> <span class="keyword">and</span> args.world_size == <span class="number">-1</span>:</span><br><span class="line">        args.world_size = int(os.environ[<span class="string">"WORLD_SIZE"</span>])</span><br><span class="line"></span><br><span class="line">    args.distributed = args.world_size &gt; <span class="number">1</span> <span class="keyword">or</span> args.multiprocessing_distributed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.multiprocessing_distributed:</span><br><span class="line">        <span class="comment"># Since we have ngpus_per_node processes per node, the total world_size needs to be adjusted accordingly</span></span><br><span class="line">        args.world_size = ngpus_per_node * args.world_size</span><br><span class="line">        <span class="comment"># Use torch.multiprocessing.spawn to launch distributed processes: the main_worker process function</span></span><br><span class="line">        mp.spawn(main_worker, nprocs=ngpus_per_node, args=(args,))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        main_worker(args.gpu, args)</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是提交多进程任务。我们设置 <code>args.multiprocessing_distributed</code> 为 <code>True</code> 即可启动多进程分布式训练。<code>ngpus_per_node</code> 是单机上卡的数量，我们以此为标准，设置 <code>world_size</code> 也就是要启动的进程数量。然后通过 <code>torch.multiprocessing.spawn</code> 直接提交每个进程的任务。</p><p><code>args.dist_url</code> 是通信方式，<code>env://</code> 以及 <code>os.environ[&quot;WORLD_SIZE&quot;]</code> 都表示通过环境变量设置任务参数，这个不需要去纠结，不这样用就行了，通过命令行参数传入方便简单而且灵活，等你真的有大规模集群的时候再考虑通过环境配置这些参数。</p><h5 id="初始化分布式训练"><a href="#初始化分布式训练" class="headerlink" title="初始化分布式训练"></a>初始化分布式训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_worker</span><span class="params">(gpu, args)</span>:</span></span><br><span class="line">    args.gpu = gpu</span><br><span class="line">    <span class="keyword">if</span> args.gpu <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">"Use GPU: &#123;&#125;"</span>.format(args.gpu))</span><br><span class="line">    <span class="keyword">global</span> best_result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.distributed:</span><br><span class="line">        <span class="keyword">if</span> args.dist_url == <span class="string">"env://"</span> <span class="keyword">and</span> args.rank == <span class="number">-1</span>:</span><br><span class="line">            args.rank = int(os.environ[<span class="string">"RANK"</span>])</span><br><span class="line">        <span class="keyword">if</span> args.multiprocessing_distributed:</span><br><span class="line">            <span class="comment"># For multiprocessing distributed training, rank needs to be the global rank among all the processes.</span></span><br><span class="line">            args.rank = args.rank * ngpus_per_node + args.gpu</span><br><span class="line">        torch.distributed.init_process_group(backend=args.dist_backend,</span><br><span class="line">                                             init_method=args.dist_url,</span><br><span class="line">                                             world_size=args.world_size,</span><br><span class="line">                                             rank=args.rank)</span><br></pre></td></tr></table></figure><p><code>main_worker</code> 就是每个进程实际执行的任务了，也比较好理解。这里有一个需要注意的地方：<code>torch.multiprocessing.spawn()</code> 要求提交的任务函数第一个参数是 gpu_id，并且启动多进程传参的时候不传入这个参数，是默认传入的。</p><p>这里首先设置了当前进程的 <code>rank</code>，也是通过传入的 gpu_id 设置的，也就是 GPU_0 就是 <code>rank=0</code> 了。然后最重要的就是分布式初始化了：<code>init_process_group()</code>。</p><p><code>backend</code> 参数可以参考 <a href="https://pytorch.org/docs/master/distributed.html?highlight=distributed#backends" target="_blank" rel="noopener">PyTorch Distributed Backends</a>，也就是分布式训练的底层实现，GPU 用 <code>nccl</code>，CPU 用 <code>gloo</code>，不用选了。</p><blockquote><p>这里需要注意，选择了 GPU 或者 CPU 之后，多进程通信的操作就只限于 GPU 数据和 CPU 数据了，比如 <code>nccl</code> 就不支持 CPU 数据的一些操作。</p></blockquote><p><code>init_method</code> 参数就是多进程通信的方式，前文说了通过命令行 <code>args.dist_url</code> 传入即可，单机多卡直接无脑 TCP 就行，又快又稳，比如：<code>tcp://127.0.0.1:8009</code>，随便选一个没有被占用的端口即可。</p><p><code>world_size</code> 和 <code>rank</code> 前文已经说过了。</p><p>注意，<code>main_worker</code> 函数里的每一行代码都会在每个进程上单独执行，这里可以看到，不同的进程仅仅是使用了不同的 <code>rank</code>，后续也是通过这个参数去区分不同的进程。我一般是会选择一个 master，也就是 <code>rank=0</code> 用于我的一些打印信息和其他操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_worker</span><span class="params">(gpu, args)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.multiprocessing_distributed <span class="keyword">or</span> (args.multiprocessing_distributed <span class="keyword">and</span> args.rank % ngpus_per_node == <span class="number">0</span>):</span><br><span class="line">        args.master = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        args.master = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="训练数据处理"><a href="#训练数据处理" class="headerlink" title="训练数据处理"></a>训练数据处理</h4><p><code>torch.nn.DataParallel</code> 接口之所以说简单是因为数据是在全局进程中处理，所以不需要对 DataLoader 做特别的处理。PyTorch 分布式训练的原理是把数据直接切分成 <code>world_size</code> 份，然后在每个进程内独立处理数据、前向和反向传播，所以快。因此也必须要对 DataLoader 做一些处理，其实也是非常简单的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.distributed.is_initialized():</span><br><span class="line">    train_sampler = torch.utils.data.distributed.DistributedSampler(train_dataset, shuffle=Tru)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    train_sampler = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                            batch_size=batch_size,</span><br><span class="line">                                            shuffle=(train_sampler <span class="keyword">is</span> <span class="literal">None</span>),</span><br><span class="line">                                            num_workers=workers,</span><br><span class="line">                                            worker_init_fn=_worker_init_fn,</span><br><span class="line">                                            pin_memory=<span class="literal">True</span>,</span><br><span class="line">                                            sampler=train_sampler,</span><br><span class="line">                                            collate_fn=fast_collate)</span><br></pre></td></tr></table></figure><p>通过 <code>torch.distributed.is_initialized()</code> 我们就可以检查每个进程是否被分布式初始化了，然后直接调用 <code>torch.utils.data.distributed.DistributedSampler()</code> 实例化一个数据分发的对象，通过这个 sampler 把数据发到各个进程中。这里要特别注意一点，首先，然后使用了 <code>DistributedSampler</code>，那么 DataLoader 中的 <code>shuffle</code> 参数是无效的，这是必然的，因为数据是在最开始就直接被切分了的，每个卡在整个训练期间的时候只能看到自己的那块数据，当然，你可以设置 sampler 内部 shuffle，而且也有一个办法避免；其次，<strong>切分和 rank 无关，而且不保证连续</strong>，这是我多次实验的结论，也就是说每个卡的得到哪些数据我们完全不可控，这就是说如果你想用多卡推理，然后把推理结果和原数据顺序对应起来基本不可能，非常无语。</p><p>数据处理还有一个提示，PyTorch 文档中写的：</p><blockquote><p>In distributed mode, calling the <code>set_epoch()</code> method at the beginning of each epoch before creating the <code>DataLoader</code> iterator is necessary to make shuffling work properly across multiple epochs. Otherwise, the same ordering will be always used.</p></blockquote><p>什么意思呢？就是如果你想每个 epoch 每个卡的数据都充分 shuffle 而不是像我上面说的那样每张卡整个训练过程中只能看到自己的那部分数据，你就需要在每次迭代的过程中调用 <code>DistributedSampler.set_epoch()</code> 方法。这个就是前面提到避免每张卡只看到一部分数据的方法。我自己觉得用不用都可。</p><h4 id="多进程数据操作"><a href="#多进程数据操作" class="headerlink" title="多进程数据操作"></a>多进程数据操作</h4><p>多进程有一些麻烦事，比如打印这些，最好设置在 master 中进程，可能代码中比较多的 <code>if master</code> 了，另外一个就是我个人需求，我希望每个 epoch 能够对整个测试数据做评测，而不是 master 那自己的一部分，这个就涉及多进程间数据合并和通信了。代码为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logits = torch.cat(logits_list, dim=<span class="number">0</span>)</span><br><span class="line">targets = torch.cat(targets_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For distributed parallel, collect all data and then run metrics.</span></span><br><span class="line"><span class="keyword">if</span> torch.distributed.is_initialized():</span><br><span class="line">    logits_gather_list = [torch.zeros_like(logits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ngpus_per_node)]</span><br><span class="line">    torch.distributed.all_gather(logits_gather_list, logits)</span><br><span class="line">    logits = torch.cat(logits_gather_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    targets_gather_list = [torch.zeros_like(targets) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ngpus_per_node)]</span><br><span class="line">    torch.distributed.all_gather(targets_gather_list, targets)</span><br><span class="line">    targets = torch.cat(targets_gather_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">accuracy, recall, precision, auc = classification_metrics(logits, targets)</span><br></pre></td></tr></table></figure><p><code>logits</code> 和 <code>targets</code> 是常见的分类网络的输出和标签了，如果分布式训练，则通过 <code>torch.distributed.all_gather()</code> 这个操作，将各个进程的数据都搜集到一块，然后再处理。这里的搜集方式看代码结合<a href="https://pytorch.org/docs/master/distributed.html?highlight=all_gather#torch.distributed.all_gather" target="_blank" rel="noopener">官方文档</a>就明白了，很简单。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我自己使用 PyTorch 多进程分布式训练的经验了，没有太多原理讲解，想看其实现原理直接网上搜就行，具体怎么用看我给的代码就会了。根据我的经验，直接将这些流程嵌入到已有代码中即可，对于一些处理、打印、TensorBoard 等等都交给 master，缺点就是只能反映部分，不能反映整体，算是目前的一些不足吧。我的训练环境主要是单机多卡，写这篇文章也是结合我自己的使用经验，所以肯定有很多地方没照顾到，但是以实践为主看完这篇文章就可以上手了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch 可以通过 &lt;code&gt;torch.nn.DataParallel&lt;/code&gt; 直接切分数据并行在单机多卡上，实践证明这个接口并行力度并不尽如人意，主要问题在于数据在 master 上处理然后下发到其他 slaver 上训练，而且由于 &lt;a href=&quot;https://murphypei.github.io/blog/2017/05/python-GIL&quot;&gt;GIL&lt;/a&gt; 的存在只有计算是并行的。&lt;code&gt;torch.distributed&lt;/code&gt; 提供了更好的接口和并行方式，搭配多进程接口 &lt;code&gt;torch.multiprocessing&lt;/code&gt; 可以提供更加高效的并行训练。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="multiprocessing" scheme="https://murphypei.github.io/tags/multiprocessing/"/>
    
      <category term="PyTorch" scheme="https://murphypei.github.io/tags/PyTorch/"/>
    
      <category term="distributed" scheme="https://murphypei.github.io/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中熵、交叉熵和 KL 散度的介绍</title>
    <link href="https://murphypei.github.io//blog/2020/09/entrogy-kld.html"/>
    <id>https://murphypei.github.io//blog/2020/09/entrogy-kld.html</id>
    <published>2020-09-15T02:38:59.000Z</published>
    <updated>2021-02-20T03:32:19.540Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前的文章：<a href="https://murphypei.github.io/blog/2019/12/entropy.html">机器学习中关于熵的一些概念</a> 已经记录了机器学习中一些常见的关于熵的概念，最近看到一篇关于交叉熵和 KL 散度的英文文章，觉得不错，就大概翻译记录一下。</p><a id="more"></a><p>熵这一术语起源于统计热力学，是物理学的一个子领域。然而对于机器学习，我们更感兴趣的是信息论或香农熵定义的熵。这种熵的表述与信息的相关概念密切相关。熵是从某个随机过程产生的信息的平均速率。因此，我们首先需要解释“信息”一词在信息理论上下文中的含义。</p><h3 id="信息和概率"><a href="#信息和概率" class="headerlink" title="信息和概率"></a>信息和概率</h3><p>信息论中的信息通常是以比特为单位来衡量的，它可以被宽泛地定义为从一个给定事件中产生的“惊奇”的数量。举一个简单的例子——想象一下，我们有一个极其不公平的硬币，当抛出时，它有 99% 的机会正面着陆，而反面着陆的机会只有 1% 。我们可以使用集合符号 ${0.99, 0.01}$ 来表示。</p><p>如果我们掷硬币一次，硬币正面朝上落地，我们不会感到很惊讶，因此这种事件“传递”的信息很低。或者，如果它落在反面，我们会非常惊讶（考虑到我们对硬币的了解），因此这样一个事件的信息会很高。这在数学上可以用以下公式表示:</p><script type="math/tex; mode=display">I(E) = -log[Pr(E)] = -log(P)</script><p>这个方程给出了随机事件 E 中包含的信息：由<strong>事件概率的负对数</strong>给出的。这可以更简单地表示为 $-log(p)$。需要注意的一点是，如果我们处理的是以比特表示的信息，即每个比特不是 0 就是 1，对数的底是 2，所以 $I(E) = -log_{2}(p)$。机器学习中经常使用的一个替代单元是 <strong>nats</strong>，它适用于使用自然对数的地方。</p><p>对于我们不公平硬币的掷硬币事件，正面所包含的信息为 $-log_{2}(0.99) = 0.0144$ 位，这个值相当低，负面的信息等于 6.64 位。因此，这与上面讨论过的对信息的解释很好地吻合。</p><p>现在，回想一下熵被定义为从一个随机过程中产生的平均信息率。抛硬币过程中产生的平均或预期信息率是多少？</p><h3 id="熵和信息"><a href="#熵和信息" class="headerlink" title="熵和信息"></a>熵和信息</h3><p>我们如何计算事物的期望值或平均值？回想一下，变量 $x$ 的期望值是:</p><script type="math/tex; mode=display">E[X] = \sum_{i=1}^{n} x_{i}p_{i}</script><p>其中 $x<em>{i}$ 是 $x$ 的某个可能值，$p</em>{i}$ 是该可能值出现的概率。<strong>熵是信息的期望</strong>，因此定义为：</p><script type="math/tex; mode=display">H(X) = E[I(X)] = E[-log(P(X))] = -\sum_{i=1}^{n}P(x_{i})logP(x_{i})</script><p>同样是上述的抛硬币问题，可以很容易求解抛硬币这件事的熵：</p><script type="math/tex; mode=display">H(X) = -(0.99log(0.99) + 0.01log(0.01)) = 0.08bit</script><p>可以说，不公平硬币是一个平均信息传递率为 0.08bit 的随机信息发生器。这是相当小的，因为它被正面结果的高概率所支配。然而，应该指出的是，一枚公平的硬币会产生 1bit 的熵。以上这个例子应该能让你清楚地知道熵是什么，它测量的是什么，以及如何计算它。</p><h3 id="机器学习和熵"><a href="#机器学习和熵" class="headerlink" title="机器学习和熵"></a>机器学习和熵</h3><p>你可能想知道熵在机器学习中的应用，比如交叉熵的核心概念，你们可能已经很熟悉了，我稍后也将详细介绍。然而，熵本身也被用于机器学习。一个值得注意的和有指导意义的例子是它在强化学习的政策梯度优化中的应用。在这种情况下，训练一个神经网络来控制某个 agent，其输出由一个 softmax 层组成。这个 softmax 层是 agent 的 action 的一个概率分布，根据这个概率分布可以选择最佳 action。</p><p>比如对于一个 action 空间为 4 的强化网络，其输出结果可能为：${0.9, 0.05, 0.025, 0.025}$。在这个例子中，代理最有可能选择第一个操作（即概率为 0.9）。但熵是怎么产生的呢？强化学习中需要解决的一个关键问题是确保 agent 不会过快地学会在一组行动或策略上收敛，也就是所谓的鼓励性探索。在强化学习的政策梯度版本中，可以通过将输出层熵的负值放入损失函数来鼓励探索。因此，随着损失最小化，行为概率趋于缩小和稳定，以抵消负熵的增加。</p><blockquote><p>这一段比较难翻译，大概意思就是如果 softmax 收敛到某个结果（概率很大），则熵比较小（事件很确定，参考上述 0.99 的硬币）。而强化学习中鼓励探索性搜索，所以希望熵大一点，也就是概率分布在每个 action 上都比较平均。所以将熵的负值加入到损失函数中。这样相当于最小化损失函数时，鼓励熵增。</p></blockquote><p>比如上述的例子，如果 softmax 输出是 ${0.9, 0.05, 0.025, 0.025}$，则其在损失函数中的负熵为：-0.61。如果输出是 ${0.3, 0.2, 0.25, 0.25}$，则其在损失函数中的负熵为：-1.98，损失函数的值也因此变小，因此这也是损失函数优化的一种方向趋势。</p><p>在机器学习的某些贝叶斯方法中也使用了熵，但这里不讨论熵。现在是考虑常用交叉熵损失函数的时候了。</p><h3 id="交叉熵和-KL-散度"><a href="#交叉熵和-KL-散度" class="headerlink" title="交叉熵和 KL 散度"></a>交叉熵和 KL 散度</h3><p>交叉熵的核心是测量两个概率分布 P 和 Q 之间的“距离”。正如你所观察到的，<strong>熵本身只是一个概率分布的度量</strong>。因此如果我们试图找到一种方法来建模一个真正的概率分布 P，比如说使用一个神经网络产生一个近似的概率分布 Q，那么就需要某种可以最小化的距离或差异度量。交叉熵的差异度量来源于 Kullback-Leibler(KL) 散度。这可以从交叉熵函数的定义中看出:</p><script type="math/tex; mode=display">H(p, q) = H(p) + D_{KL}(p \parallel q)</script><p>第一个项，在优化过程中，<strong>真实概率分布 P 的熵是固定的</strong>，因此它在优化过程中是一个附加常数。在优化过程中，只有第二种近似分布的参数 Q 可以改变，因此度量两种分布距离的交叉熵的核心就是 KL 散度函数。</p><blockquote><p>这个是转换的核心，特别是对于机器学习来说，训练集的数据和标签集合就是真实概率分布，对于确定的训练集，这个概率分布是确定的，也就是在训练过程中是一个常数。所以多分类训练的时候，交叉熵损失可以用 KL 散度代替。</p></blockquote><p>从信息论的角度来看，两个分布之间的 KL 散度有许多不同的解释。简而言之，这也是一种“惊讶”的表达方式。假设 P 和 Q 很接近，如果事实证明它们并非如此，那就令人惊讶了，因此在这些情况下，KL 散度将会很大。如果它们靠得很近，那么 KL 散度就会很低。</p><blockquote><p>惊讶本质就是描述事件包含的信息。散度本质就是距离。</p></blockquote><p>从贝叶斯观点来看，KL 散度的另一种解释也是非常直观的。这种解释认为 KL 分歧是当我们从先验概率分布 Q 到后验概率分布 P 时所获得的信息。KL 散度的表达式也可以用似然比的方法推导出来。</p><blockquote><p>关于先验概率和后验概率，以及最大后验概率估计，可以参考<a href="https://murphypei.github.io/blog/2020/03/mle-map.html">最大似然估计和最大后验概率估计</a>。</p></blockquote><h4 id="贝叶斯方法推导-KL-散度"><a href="#贝叶斯方法推导-KL-散度" class="headerlink" title="贝叶斯方法推导 KL 散度"></a>贝叶斯方法推导 KL 散度</h4><p>似然比函数定义：</p><script type="math/tex; mode=display">LR = \frac{p(x)}{q(x)}</script><p>这可以解释为：如果一个值 $x$ 是从某个未知的分布中取样，似然比表示样本来自分布 P 的可能性比来自分布 Q 的可能性大多少。如果它更有可能来自 P，LR &gt; 1，否则如果它更有可能来自 Q，LR &lt; 1。</p><p>假设我们有很多独立的样本，我们想要在考虑到所有这些证据的情况下，估计出可能性函数，然后变成：</p><script type="math/tex; mode=display">LR = \prod_{i=0}^{n}\frac{p(x_{i})}{q(x_{i})}</script><p>如果我们把这个比率转换成对数，就可以把上面定义中的乘积变成一个总和：</p><script type="math/tex; mode=display">LR = \sum_{i=0}^{n}log\left(\frac{p(x_{i})}{q(x_{i})}\right)</script><p>现在我们把似然比作为总和。假设我们想要回答这样一个问题: 平均每个样本可能性, $p(x)$ 比 $q(x)$ 大多少？要做到这一点，我们可以采取的期望值的似然比，并得到：</p><script type="math/tex; mode=display">D_{KL}(P\parallel Q) = \sum_{i=0}^{n}p(x_{i})log\left(\frac{p(x_{i})}{q(x_{i})}\right)</script><p>上面的表达式就是 KL 散度的定义。它基本上是似然比的期望值。其中似然比表示的是样本数据来自分布 P 而不是分布 Q 的可能性有多大。另一种表示上述定义的方法如下(使用对数规则) :</p><script type="math/tex; mode=display">D_{KL}(P\parallel Q) = \sum_{i=0}^{n}p(x_{i})log (p(x_{i})) – \sum_{i=0}^{n}p(x_{i})log (q(x_{i}))</script><p>上述方程中的第一项是分布 P 的熵。正如你所记得的，它是 P 的信息含量的期望值。第二项是 Q 的信息量，但是通过 P 的分布加权的（而不是 Q 的分布）。如果 P 是“真实”分布，那么 KL 散度就是该分布通过 Q 表达（或称为<strong>编码</strong>）时“丢失”的信息量。</p><p>不管你怎么解释 KL 散度，它显然是概率分布 P 和 Q 之间的差值。然而它只是一个“准”距离测度，因为 $D<em>{KL}(P \parallel Q) \neq D</em>{KL}(Q \parallel P)$。</p><p>现在我们需要说明 KL 散度是如何产生交叉熵函数的。</p><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>如前所述，交叉熵是“真实”分布 P 的熵和 P 与 Q 之间 KL 散度的组合：</p><script type="math/tex; mode=display">H(p, q) = H(p) + D_{KL}(p \parallel q)</script><p>利用熵和 KL 散度的定义，以及对数规则，我们可以得到以下交叉熵的定义:</p><script type="math/tex; mode=display">H(p, q) = – \sum_{i=0}^{n}p(x_{i})log (q(x_{i}))</script><p>在神经网络的分类任务中使用这个函数看起来像什么？在这样的任务中，我们通常要处理的真实分布 P 是一个 one-hot 编码。例如在 MNIST 手写数字分类任务中，如果图像表示手写数字“2” ，P 就是：${0, 0, 1, 0, 0, 0, 0, 0, 0, 0}$。</p><p>我们的神经网络在这样一个任务的输出层将是一个 softmax层，其中所有的输出已被规范化，所以他们的和为 1，代表一个准概率分布。这张图片的输出层 Q 可以是：${0.01, 0.02, 0.75, 0.05, 0.02, 0.1, 0.001, 0.02, 0.009, 0.02}$。</p><p>为了得到预测的类，我们将在输出上运行 $argmax$，在这个例子中，我们将得到正确的预测。然而，观察交叉熵损失函数在这种情况下是如何工作的。对于除 $i=2$ 以外的所有值，$p(x_{i})=0$，因此这些索引的总和中的值为 0。唯一没有零值的索引是 $i=2$。因此，对于 one-hot 编码向量，交叉熵折叠为:</p><script type="math/tex; mode=display">H(p,q) = -log(q(x_{i}))</script><p>在本例中，交叉熵损失为 $-log(0.75)=0.287$（使用 nats 作为信息单位）。对于 $i=2$ 指数，Q 值越接近 1，损失就越小。这是因为对于这个指标，P 和 Q 之间的 KL 散度减小了。</p><p>有人可能会问，如果交叉熵损失的分类任务降低到一个单一的输出节点计算，神经网络如何学习既增加真实索引的值，并减少所有其他节点的值？它通过节点之间通过权重进行交叉相互作用来实现这一点，通过 softmax 激活函数指数本身的性质（各项相加等于 1），如果一个单一的指数被鼓励增加，那么所有其他的指数/输出类别将被鼓励在 softmax 激活函数中减少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前的文章：&lt;a href=&quot;https://murphypei.github.io/blog/2019/12/entropy.html&quot;&gt;机器学习中关于熵的一些概念&lt;/a&gt; 已经记录了机器学习中一些常见的关于熵的概念，最近看到一篇关于交叉熵和 KL 散度的英文文章，觉得不错，就大概翻译记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://murphypei.github.io/categories/MachineLearning/"/>
    
    
      <category term="熵" scheme="https://murphypei.github.io/tags/%E7%86%B5/"/>
    
      <category term="KLD" scheme="https://murphypei.github.io/tags/KLD/"/>
    
      <category term="交叉熵" scheme="https://murphypei.github.io/tags/%E4%BA%A4%E5%8F%89%E7%86%B5/"/>
    
      <category term="KL 散度" scheme="https://murphypei.github.io/tags/KL-%E6%95%A3%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>win10 上使用 SSH 实践</title>
    <link href="https://murphypei.github.io//blog/2020/07/win10-ssh.html"/>
    <id>https://murphypei.github.io//blog/2020/07/win10-ssh.html</id>
    <published>2020-07-27T04:24:54.000Z</published>
    <updated>2021-02-20T03:35:48.240Z</updated>
    
    <content type="html"><![CDATA[<p>win10 已经使用的越来越顺手，而且越发喜爱在 win10 上工作了，随手记录一下一些使用的体验和配置。</p><a id="more"></a><p>工作中使用跳板机和服务器是不可避免的，win10 中内置了 SSH 服务，可以很方便的满足我们的需求。</p><p>首先，远程 SSH 必须要有一个给力的 terminal，这里我大力推荐 windows-terminal，微软自家研发的，很有 vscode 的味道，爱不释手，目前的缺点是必须有些版本（1903以上）才能用，而且看上去比较简单，配置起来略显麻烦。关于配置，可以参考<a href="https://sspai.com/post/59380" target="_blank" rel="noopener">新生代 Windows 终端：Windows Terminal 的全面自定义</a>。</p><p>一般公司都是通过密钥登陆的，这里也比较推荐这种方式。关于密钥登录的方式以及 SSH 服务器的密钥登陆配置，可以自行查资料。不再赘述。</p><p>假设服务器已经配置了密钥登陆，那么服务器会产生一个公钥 <code>id_rsa.pub</code> 和私钥 <code>id_rsa</code>，其中公钥会写入到服务器的 <code>~/.ssh/authorized_keys</code> 中（可以添加多个公钥）。私钥就是我们用于登录服务器的。可以通过 <code>ssh -i id_rsa xxx</code> 来登录服务器。私钥和公钥是通过 <code>ssh-keygen</code> 产生的，如果产生的过程中私钥有密码，还需要输入密码。</p><p>以上登录方式每次都需要输入私钥路径，我们可以配置本地机器的 <code>~/.ssh/config</code> 来达到简化目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host ubuntu</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  HostName 1.1.1.1</span><br><span class="line">  Port 1111</span><br><span class="line">  User murphy</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>id_rsa</code> 是服务器上的公钥（写进 <code>~/.ssh/authorized_keys</code>）对应的私钥。</p></blockquote><p>如此处理之后，我们就可以直接通过 <code>ssh ubuntu</code> 来登录这台机器了。</p><h3 id="跳板机的处理"><a href="#跳板机的处理" class="headerlink" title="跳板机的处理"></a>跳板机的处理</h3><p>跳板机一般通过 SSH ProxyCommand 来实现直连，命令和 Linux 有一点点区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host k8s006</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  HostName 2.2.2.2</span><br><span class="line">  User murphy</span><br><span class="line">  Port 2222</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  ProxyCommand C:\Windows\System32\OpenSSH\ssh.exe ubuntu -q -X -W %h:%p</span><br></pre></td></tr></table></figure><blockquote><p>这里是以上文设置的 ubuntu 作为跳板机。</p></blockquote><p>这些需要注意的是，ProxyCommand 需要利用 <code>ssh-agent</code> 服务，这个在 windows 上是默认关闭的。我们可以将其设置为自动打开。</p><ol><li><p>检查 <code>ssh-agent</code> 服务的状态：</p><p> <code>Get-Service | select -property name,starttype</code></p><p> 在其中找到 <code>ssh-agent</code>，查看其状态，一般情况下应该是 disabled。</p></li><li><p>设置 <code>ssh-agent</code> 服务的启动方式（管理员运行）：</p><p> <code>Set-Service -Name ssh-agent -StartupType Manual</code></p><p> 这里可以是 <code>Manual</code>，也可以是 <code>Automatic</code>。</p></li><li><p>手动打开 <code>ssh-agent</code> 服务：</p><p> <code>Start-Service ssh-agent</code></p><p> 如果设置不生效，或者为 <code>Manual</code>，也可以手动打开。</p></li></ol><h3 id="保存密钥的密码"><a href="#保存密钥的密码" class="headerlink" title="保存密钥的密码"></a>保存密钥的密码</h3><p>如果产生密钥的时候设置了密码，那么每次登录的时候都需要密码，可以通过设置缓存解决。</p><p><code>ssh-add ~/.ssh/id_rsa</code>。</p><blockquote><p>这条命令也需要 <code>ssh-agent</code> 服务。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;win10 已经使用的越来越顺手，而且越发喜爱在 win10 上工作了，随手记录一下一些使用的体验和配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://murphypei.github.io/categories/Windows/"/>
    
    
      <category term="win10" scheme="https://murphypei.github.io/tags/win10/"/>
    
      <category term="SSH" scheme="https://murphypei.github.io/tags/SSH/"/>
    
      <category term="ssh-keygen" scheme="https://murphypei.github.io/tags/ssh-keygen/"/>
    
      <category term="ssh-agent" scheme="https://murphypei.github.io/tags/ssh-agent/"/>
    
      <category term="ssh-add" scheme="https://murphypei.github.io/tags/ssh-add/"/>
    
  </entry>
  
  <entry>
    <title>ResNet 原理剖析</title>
    <link href="https://murphypei.github.io//blog/2020/06/why-resnet.html"/>
    <id>https://murphypei.github.io//blog/2020/06/why-resnet.html</id>
    <published>2020-06-27T03:01:55.000Z</published>
    <updated>2021-02-20T03:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>ResNet 算是深度学习里程碑之作了，我平时接触也比较多，写一篇文章做一些记录总结。</p><a id="more"></a><h2 id="引言：为什么会有-ResNet？"><a href="#引言：为什么会有-ResNet？" class="headerlink" title="引言：为什么会有 ResNet？"></a>引言：为什么会有 ResNet？</h2><blockquote><p>神经网络叠的越深，则学习出的效果就一定会越好吗？</p></blockquote><p>答案无疑是否定的，人们发现当模型层数增加到某种程度，模型的效果将会不升反降。也就是说，深度模型发生了<strong>退化（degradation）</strong>情况。</p><p>那么，为什么会出现这种情况？我们从以下几点来分析。</p><h3 id="过拟合（overfitting）问题"><a href="#过拟合（overfitting）问题" class="headerlink" title="过拟合（overfitting）问题"></a>过拟合（overfitting）问题</h3><p>首先看一下吴恩达机器学习公开课中所描述的过拟合问题：</p><p><img src="/images/posts/dl/resnet/andrew_ng_ml_overfitting.jpg" alt="过拟合"></p><p>在这个多项式回归问题中，左边的模型是欠拟合（underfit）的此时有很高的偏差（high bias），中间的拟合比较成功，而右边则是典型的过拟合（overfit），此时由于<strong>模型过于复杂</strong>，导致了高方差（high variance）。</p><p>然而，很明显当前CNN面临的效果退化不是因为过拟合，因为过拟合的现象是”高方差，低偏差”，即测试误差大而训练误差小。但实际上，<strong>深层CNN的训练误差和测试误差都很大</strong>。所以也不完全是过拟合的问题。</p><p><img src="/images/posts/dl/resnet/deep_model_degradation.jpg" alt="深层网络模型退化"></p><h3 id="梯度消失和爆炸（Gradient-vanishing-exploding）"><a href="#梯度消失和爆炸（Gradient-vanishing-exploding）" class="headerlink" title="梯度消失和爆炸（Gradient vanishing/exploding）"></a>梯度消失和爆炸（Gradient vanishing/exploding）</h3><p>除此之外，最受人认可的原因就是“梯度爆炸/消失（弥散）”了。为了理解什么是梯度弥散，首先回顾一下反向传播的知识。</p><p>假设我们现在需要计算一个函数：$f(x,y,z)=(x+y) \times z$ 在 $x=-2,y=5,z=-4$ 时的梯度，那么计算流程如下：</p><ol><li>前向传播计算 $f(x=-2,y=5,z=-4)$ 的结果为 -12。</li><li>令 $q=x+y$ ，可以推导反向传播：</li></ol><script type="math/tex; mode=display">\frac {df} {dz} = q = x + y = 3</script><script type="math/tex; mode=display">\frac {df} {dx} = \frac {df} {dq} \cdot \frac {dq} {dx} = z \cdot 1 = -4</script><script type="math/tex; mode=display">\frac {df} {dy} = \frac {df} {dq} \cdot \frac {dq} {dy} = z \cdot 1 = -4</script><p>上面的前向传播和反向传播学过微积分的都应该明白。反向传播其实就是输出端梯度通过链式法则向输入端传播的过程，这里假设输出端初始的梯度为 1，也就是输出端对自身求导等于 1。</p><p>观察上述反向传播，不难发现，在输出端梯度的模值，经过回传扩大了3~4倍。</p><p>这是由于反向传播结果的<strong>数值大小</strong>不止取决于求导的式子，很大程度上也取决于<strong>输入的模值。</strong>当计算图每次输入的模值都大于1，那么经过很多层回传，梯度将不可避免地呈几何倍数增长（每次都变成 3~4 倍，重复上万次，想象一下 3 的 10000 次方有多大……），直到Nan。这就是<strong>梯度爆炸</strong>现象。</p><p>当然反过来，如果我们每个阶段输入的模恒小于 1，那么梯度也将不可避免地呈几何倍数下降（比如每次都变成原来的三分之一，重复一万次就是 3 的 -10000 次方），直到 0。这就是梯度消失现象。值得一提的是，由于人为的参数设置，<strong>梯度更倾向于消失而不是爆炸</strong>。</p><p>由于至今神经网络都以反向传播为参数更新的基础，所以梯度消失问题听起来很有道理。然而，事实也并非如此，至少不止如此。</p><p>我们现在无论用 Pytorch 还是 Tensorflow，都会自然而然地加上 Bacth Normalization，<strong>而 BN 的作用本质上也是控制每层输入的模值，</strong>因此梯度的爆炸/消失现象理应在很早就被解决了（至少解决了大半）。</p><p>不是过拟合，也不是梯度消失，这就很尴尬了……CNN 没有遇到我们熟知的两个老大难问题，却还是随着模型的加深而导致效果退化。无需任何数学论证，我们都会觉得这不符合常理。</p><h3 id="为什么模型退化不符合常理？"><a href="#为什么模型退化不符合常理？" class="headerlink" title="为什么模型退化不符合常理？"></a>为什么模型退化不符合常理？</h3><p>He 在论文中举了一个例子，假设一个比较浅的网络已经可以达到不错的效果，<strong>那么即使之后堆上去的网络什么也不做，模型的效果也不会变差</strong>。而之前的深度网络出现退化问题，所以很明显什么都不做恰好是当前神经网络最难做到的东西之一。</p><blockquote><p>MobileNet V2 的论文也提到过类似的现象，由于非线性激活函数 ReLU 的存在，每次输入到输出的过程都几乎是不可逆的（信息损失）。我们很难从输出反推回完整的输入。因此 MobileNet V2 论文中选择去掉低维的 ReLU 以保留特征信息。</p></blockquote><p>我们可以认为，为了实现非线性，激活函数让特征在传播过程中丢失了信息，因此这类的神经网络都无法做到“恒等映射”。</p><p>因此，可以认为 Residual Learning 的初衷，其实是让模型的内部结构至少有恒等映射的能力。以保证在堆叠网络的过程中，网络至少不会因为继续堆叠而产生退化！</p><h2 id="深度残差学习（Deep-Residual-Learning）"><a href="#深度残差学习（Deep-Residual-Learning）" class="headerlink" title="深度残差学习（Deep Residual Learning）"></a>深度残差学习（Deep Residual Learning）</h2><h3 id="残差学习"><a href="#残差学习" class="headerlink" title="残差学习"></a>残差学习</h3><p>前面分析得出，如果深层网络后面的层都是是<strong>恒等映射</strong>，那么模型就可以转化为一个浅层网络。那现在的问题就是<strong>如何得到恒等映射</strong>了。但是要让一个神经网络你和 $H(x)=x$ 其实是非常困难的。于是 He 等人换了一个思路，把网络设计为 $H(x) = F(x) + x$，即直接把恒等映射作为网络的一部分<strong>。就可以把问题转化为</strong>学习一个残差函数 $F(x) = H(x) - x$。</p><p>只要 $F(x)=0$，就构成了一个恒等映射 $H(x) = x$。 而且，拟合残差至少比拟合恒等映射容易得多。于是，就有了 Residual block 结构。</p><p><img src="/images/posts/dl/resnet/residual_block.jpg" alt></p><p>图中右侧的曲线叫做跳接（shortcut connection），通过跳接在<strong>激活函数前，</strong>将上一层（或几层）<strong>之前的输出与本层</strong>计算的<strong>输出相加</strong>，将求和的结果输入到激活函数中做为本层的输出。</p><p>用数学语言描述，假设 Residual Block 的输入为 $x$，则输出 $y$ 等于：$y=F(x, {W_i}) + x$。$F$ 就是我们要学习的目标，即输出和输入的残差 $y-x$ 。</p><p>上图中的计算可以表示为：$F=W_2/ \sigma(W_1x)$。也就是经过两个权重层和一个激活层。这里需要注意，<strong>一个 Residual Block 必须至少含有两个权重层</strong>，否则没有意义：$y=(W_1x) + x = (W_1 + 1) + x$。相当于权重加 1，加了和没加一样。</p><p>残差网络结构根据是否改变 feature map 大小又分为两种，也就是是否 down sample（空间减半，深度翻倍）。实际实现中就是在跳接过程中是否使用卷积进行维度和空间大小的改变。</p><h3 id="What-the-question？"><a href="#What-the-question？" class="headerlink" title="What the question？"></a>What the question？</h3><p>残差学习解决了模型退化的问题，但是模型退化是一个现象问题，其本质原因或者说深度 CNN 的本质问题是什么呢？</p><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1702.08591" target="_blank" rel="noopener">The Shattered Gradients Problem: If resnets are the answer, then what is the question?</a></p><p>论文大意是神经网络越来越深的时候，反传回来的梯度之间的相关性会越来越差，最后接近白噪声。因为我们知道图像是具备局部相关性的，那其实可以认为梯度也应该具备类似的相关性，这样更新的梯度才有意义，如果梯度接近白噪声，那梯度更新可能根本就是在做随机扰动。</p><p>论文认为即使 BN 过后梯度的模稳定在了正常范围内，但<strong>梯度的相关性实际上是随着层数增加持续衰减的</strong>。而经过证明，ResNet 可以有效减少这种相关性的衰减。大概从 $\frac {1} {2^L}$ 减小到  $\frac {1} {\sqrt(L)}$ 。这也验证了 ResNet 论文本身的观点，网络训练难度随着层数增长的速度不是线性，而至少是多项式等级的增长（如果该论文属实，则可能是指数级增长的）。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在残差网络之后，跳接给网络的设计带来了很多新的思考。以 FPN（Feature Pyramid Network）为代表的跳接网络从语义的角度解决了深度网络的特征提取问题，那就是跳连接相加可以实现不同分辨率特征的组合，因为浅层容易有高分辨率但是低级语义的特征，而深层的特征有高级语义，但分辨率就很低了。</p><p>引入跳接实际上让模型自身<strong>有了更加“灵活”的结构</strong>，即在训练过程本身，模型可以选择在每一个部分是“更多进行卷积与非线性变换”还是“更多倾向于什么都不做”，抑或是将两者结合。模型在训练便可以自适应本身的结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ResNet 算是深度学习里程碑之作了，我平时接触也比较多，写一篇文章做一些记录总结。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="深度学习" scheme="https://murphypei.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="resnet" scheme="https://murphypei.github.io/tags/resnet/"/>
    
      <category term="残差连接" scheme="https://murphypei.github.io/tags/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="模型退化" scheme="https://murphypei.github.io/tags/%E6%A8%A1%E5%9E%8B%E9%80%80%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 序列化数据格式</title>
    <link href="https://murphypei.github.io//blog/2020/04/tf-serialize-format.html"/>
    <id>https://murphypei.github.io//blog/2020/04/tf-serialize-format.html</id>
    <published>2020-04-15T04:14:38.000Z</published>
    <updated>2021-02-20T03:34:19.090Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow 保存模型结构和参数的方法有几种，日常都会遇到这些不同格式的数据，做记录总结。</p><a id="more"></a><p>一般来讲，TensorFlow 有三种文件格式：</p><ul><li>checkpoint：一种独有的文件格式，包含四个文件。保存了计算图和权重，无法直接打开阅读。多用于训练时。</li><li>pb：protobuf 格式的二进制文件，可以只保存计算图（很小），也同时保存了权重和计算图（很大），无法直接打开阅读。<ul><li>包含权重的文件中所有的 variable 都已经变成了 tf.constant 和 graph 一起 frozen 到一个文件。</li></ul></li><li>pbtxt：pb 文件的可读文本，如果同时保存权重，文件会很大，一般用的比较少，可用于调试查看网络结构。</li></ul><p>下面是我写的一个关于 TensorFlow 存储和加载不同格式的例子，配合注释就知道每种格式怎么读写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.framework.graph_util <span class="keyword">import</span> convert_variables_to_constants</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, batch_size, feature_size, hidden_size, output_size)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.feature_size = feature_size</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.output_size = output_size</span><br><span class="line"></span><br><span class="line">        self.input_file = <span class="string">"./tf_test_input.txt"</span></span><br><span class="line">        self.output_file = <span class="string">"./tf_test_output.txt"</span></span><br><span class="line">        self.ckpt_prefix = <span class="string">"./ckpt/model"</span></span><br><span class="line">        self.pb_file = <span class="string">"./pb/tf_test_model.pb"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.path.dirname(self.ckpt_prefix)):</span><br><span class="line">            os.makedirs(os.path.dirname(self.ckpt_prefix))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.path.dirname(self.pb_file)):</span><br><span class="line">            os.makedirs(os.path.dirname(self.pb_file))</span><br><span class="line"></span><br><span class="line">        self.input_name = <span class="string">'input'</span></span><br><span class="line">        self.output_name = <span class="string">'output'</span></span><br><span class="line"></span><br><span class="line">        self.prepare_data()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare_data</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x_data = np.random.random((self.batch_size, self.feature_size)) * <span class="number">2.0</span></span><br><span class="line">        self.y_data = np.random.random((self.batch_size, self.output_size)) * <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">with</span> open(self.input_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">'\n'</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> self.x_data.flatten()]))</span><br><span class="line">            print(<span class="string">"save input data to file: "</span> + self.input_file)</span><br><span class="line">        <span class="keyword">with</span> open(self.output_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">'\n'</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> self.y_data.flatten()]))</span><br><span class="line">            print(<span class="string">"save output data to file: "</span> + self.input_file)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_fc_layer</span><span class="params">(self, inputs, in_size, out_size, activation_function=None)</span>:</span></span><br><span class="line">        <span class="comment"># add one more layer and return the output of this layerb</span></span><br><span class="line">        w = tf.Variable(tf.random_normal([in_size, out_size]))</span><br><span class="line">        b = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span><br><span class="line">        y = tf.matmul(inputs, w) + b</span><br><span class="line">        <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            outputs = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outputs = activation_function(y)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_network</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> tf.Session(graph=tf.Graph()) <span class="keyword">as</span> sess:</span><br><span class="line">            x_train_data = tf.placeholder(tf.float32, shape=(self.batch_size, self.feature_size), name=self.input_name)</span><br><span class="line">            y_train_data = tf.placeholder(tf.float32, shape=(self.batch_size, self.output_size), name=<span class="string">'label'</span>)</span><br><span class="line">            l1 = self.add_fc_layer(x_train_data, self.feature_size, self.hidden_size, tf.nn.relu)</span><br><span class="line">            prediction = self.add_fc_layer(l1, self.hidden_size, self.output_size, <span class="literal">None</span>)</span><br><span class="line">            output = tf.identity(prediction, self.output_name)</span><br><span class="line"></span><br><span class="line">            loss = tf.reduce_mean(tf.reduce_sum(tf.square(y_train_data - output), reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">            train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置 checkpoint saver，用于保存 checkpoint 格式的数据。</span></span><br><span class="line">            saver = tf.train.Saver()</span><br><span class="line">            <span class="comment"># 初始化所有参数</span></span><br><span class="line">            sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">                sess.run(train_step, feed_dict=&#123;x_train_data: self.x_data, y_train_data: self.y_data&#125;)</span><br><span class="line">                <span class="comment"># snapchat</span></span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># to see the step improvement</span></span><br><span class="line">                    <span class="comment"># print(sess.run([loss, output], feed_dict=&#123;x_train_data: self.x_data, y_train_data: self.y_data&#125;))</span></span><br><span class="line">                    print(sess.run(loss, feed_dict=&#123;x_train_data: self.x_data, y_train_data: self.y_data&#125;))</span><br><span class="line">                    <span class="comment"># 每迭代 50 次，保存一次模型。这里由于没有修改名字，因为会覆盖掉前面的 checkpoint。</span></span><br><span class="line">                    saver.save(sess, self.ckpt_prefix)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存 pbtxt 格式的计算图，只有图结构，没有权重。</span></span><br><span class="line">            tf.train.write_graph(tf.get_default_graph(), <span class="string">"."</span>, self.pb_file + <span class="string">"txt"</span>, as_text=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restore_from_ckpt</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            saver = tf.train.import_meta_graph(self.ckpt_prefix + <span class="string">'.meta'</span>)</span><br><span class="line">            saver.restore(sess, tf.train.latest_checkpoint(os.path.dirname(self.ckpt_prefix)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里不能重新初始化，否则参数被覆盖了</span></span><br><span class="line">            <span class="comment"># sess.run(tf.global_variables_initializer())</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印所有 tensor</span></span><br><span class="line">            <span class="comment"># print([[n.name for n in tf.get_default_graph().as_graph_def().node]])</span></span><br><span class="line"></span><br><span class="line">            input_tensor = tf.get_default_graph().get_tensor_by_name(<span class="string">'&#123;&#125;:0'</span>.format(self.input_name))</span><br><span class="line">            output_tensor = tf.get_default_graph().get_tensor_by_name(<span class="string">'&#123;&#125;:0'</span>.format(self.output_name))</span><br><span class="line"></span><br><span class="line">            print(sess.run(output_tensor, feed_dict=&#123;input_tensor: self.x_data&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save graph as pb file</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert_to_pb</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            <span class="comment"># 从 checkpoint 中恢复模型。</span></span><br><span class="line">            saver = tf.train.import_meta_graph(self.ckpt_prefix + <span class="string">'.meta'</span>)</span><br><span class="line">            saver.restore(sess, tf.train.latest_checkpoint(os.path.dirname(self.ckpt_prefix)))</span><br><span class="line">            graph = tf.get_default_graph()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 转存为 pb 文件，同时保留计算图和 variable 的值。将 variable 转为 constant。</span></span><br><span class="line">            output_graph_def = convert_variables_to_constants(</span><br><span class="line">                sess, sess.graph_def, output_node_names=[self.output_name])</span><br><span class="line">            <span class="keyword">with</span> tf.gfile.FastGFile(self.pb_file, mode=<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(output_graph_def.SerializeToString())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restore_from_pb</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 直接从 pb 中恢复计算图和 variable 的值</span></span><br><span class="line">        <span class="keyword">with</span> tf.gfile.GFile(self.pb_file, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            graph_def = tf.GraphDef()</span><br><span class="line">            graph_def.ParseFromString(f.read())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.Session(graph=tf.get_default_graph()) <span class="keyword">as</span> sess:</span><br><span class="line">            tf.import_graph_def(graph_def, name=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印所有 tensor</span></span><br><span class="line">            <span class="comment"># print([[n.name for n in tf.get_default_graph().as_graph_def().node]])</span></span><br><span class="line"></span><br><span class="line">            input_tensor = tf.get_default_graph().get_tensor_by_name(<span class="string">'&#123;&#125;:0'</span>.format(self.input_name))</span><br><span class="line">            output_tensor = tf.get_default_graph().get_tensor_by_name(<span class="string">'&#123;&#125;:0'</span>.format(self.output_name))</span><br><span class="line">            print(sess.run(output_tensor, feed_dict=&#123;input_tensor: self.x_data&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tc = TestCase(batch_size=<span class="number">128</span>, feature_size=<span class="number">1024</span>, hidden_size=<span class="number">2048</span>, output_size=<span class="number">64</span>)</span><br><span class="line">    tc.train_network()</span><br><span class="line">    <span class="comment"># tc.restore_from_ckpt()</span></span><br><span class="line">    <span class="comment"># tc.restore_from_pb()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow 保存模型结构和参数的方法有几种，日常都会遇到这些不同格式的数据，做记录总结。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="TensorFlow" scheme="https://murphypei.github.io/tags/TensorFlow/"/>
    
      <category term="序列化" scheme="https://murphypei.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="protobuf" scheme="https://murphypei.github.io/tags/protobuf/"/>
    
      <category term="pbtxt" scheme="https://murphypei.github.io/tags/pbtxt/"/>
    
  </entry>
  
  <entry>
    <title>浅谈内存对齐</title>
    <link href="https://murphypei.github.io//blog/2020/04/memory-align.html"/>
    <id>https://murphypei.github.io//blog/2020/04/memory-align.html</id>
    <published>2020-04-12T04:14:38.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 编程中常见的一个概念是内存对齐，这里的对齐简单来讲就是分配的内存地址的起始位置是某个数字的倍数。</p><a id="more"></a><h3 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h3><p>我们知道计算内存的最小存储单位是字节（byte），一般来讲我们调用 <code>malloc</code> 这类分配内存的函数也是以字节为单位分配的。理论上来讲我们分配的内存是由内核的堆管理器管理的，所以分配的内存首地址可能是任意的，也就是所谓的<strong>没有对齐</strong>。我们还知道，C 语言的 <code>struct</code> 中会有内存对齐，存在比如每个成员的起始地址必须是其大小的倍数，整个 <code>struct</code> 大小是最大成员的倍数等规则。这其中的原因是什么呢？</p><p>其实这和计算机体系结构或者说硬件设计有关。首先，<strong>很多 CPU 只从对齐的地址开始加载数据</strong>，CPU 这样做是为了更快一点。其次，<strong>外部总线从内存一次获取的数据往往不是 1 byte，而是 4 bytes 或许 8 bytes 或者更多</strong>，具体和数据总线带宽有关，32 位计算体系中数据总线一般就是 32 bits，也就是 4 bytes。</p><p>有了以上两个原因，我们容易理解为啥要数据对齐了。比如一个 int 数据类型，其分配的 4 bytes 没有对齐，比如分配在 3，4，5，6 这 4 个字节上。而 CPU 取值是对齐的，可能就需要取 0~3，4~7 这两块的数据才能获得这个 int 数据的大小。</p><h3 id="向量指令"><a href="#向量指令" class="headerlink" title="向量指令"></a>向量指令</h3><p>以上内存对齐的需求只是最基本，常见于 C 语言编程中，现代编译器一般会处理这类的内存对齐。另一种需要程序员处理的内存对齐就是向量指令集。我们以 x86 平台的向量化运算为例。</p><p>向量化运算就是用 SSE、AVX 等 SIMD（Single Instruction Multiple Data）指令集，实现一条指令对多个操作数的运算，从而提高代码的吞吐量，实现加速效果。SSE 是一个系列，包括从最初的 SSE 到最新的 SSE4.2，支持同时操作 16 bytes 的数据，即 4 个 float 或者 2 个 double。AVX 也是一个系列，它是 SSE 的升级版，支持同时操作 32 bytes 的数据，即 8 个 float 或者 4 个 double。</p><p>但<strong>向量化运算是有前提的，那就是内存对齐</strong>。SSE 的操作数，必须 16 bytes 对齐，而 AVX 的操作数，必须 32 bytes 对齐。也就是说，如果我们有 4 个 float 数，必须把它们放在连续的且首地址为 16 的倍数的内存空间中，才能调用 SSE 的指令进行运算。</p><h3 id="栈上内存对齐"><a href="#栈上内存对齐" class="headerlink" title="栈上内存对齐"></a>栈上内存对齐</h3><p>简单以 4 个浮点数相加为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> input1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">double</span> input2[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">double</span> result[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input1: "</span> &lt;&lt; input1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input2: "</span> &lt;&lt; input2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  __m256d a = _mm256_load_pd(input1);</span><br><span class="line">  __m256d b = _mm256_load_pd(input2);</span><br><span class="line">  __m256d c = _mm256_add_pd(a, b);</span><br><span class="line"></span><br><span class="line">  _mm256_store_pd(result, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_mm256_*</code> 就是 AVX 向量指令的封装函数。<code>_mm256_load_pd</code> 指令用来加载操作数，<code>_mm256_add_pd</code> 指令进行向量化运算，最后， <code>_mm256_store_pd</code> 指令读取运算结果到 <code>result</code> 中。可惜的是，程序运行到第一个 <code>_mm256_load_pd</code> 处就崩溃了。崩溃的原因正是因为输入的变量没有内存对齐。那如何是我们的变量对齐呢？我们可以借助编译的一些特性来实现。比如 GCC 的语法为<code>__attribute__((aligned(32)))</code>，MSVC的语法为 <code>__declspec(align(32))</code>。以 GCC 语法为例，做少量修改，就可以得到正确的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> input1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> input2[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> result[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input1: "</span> &lt;&lt; input1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input2: "</span> &lt;&lt; input2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  __m256d a = _mm256_load_pd(input1);</span><br><span class="line">  __m256d b = _mm256_load_pd(input2);</span><br><span class="line">  __m256d c = _mm256_add_pd(a, b);</span><br><span class="line"></span><br><span class="line">  _mm256_store_pd(result, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上面只是示例代码，可以通过类型定义等方法优化代码的写法等等。</p><h3 id="堆上内存对齐"><a href="#堆上内存对齐" class="headerlink" title="堆上内存对齐"></a>堆上内存对齐</h3><p>以上通过编译器的修饰语法来解决内存对齐，貌似很简单，但是还是存在一个问题。以上的两个数组变量都是局部变量，也就是分配在<strong>栈上，内存地址由编译器在编译时确定</strong>，因此预编译指令会生效。但用new 和 malloc 动态创建的对象则存储在堆中，其地址在运行时确定。C++ 的运行时库并不会关心预编译指令声明的对齐方式，我们需要更强有力的手段来确保内存对齐。</p><p>废话不多说，我这里以 MNN 中的内存对齐代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> **<span class="title">alignPointer</span><span class="params">(<span class="keyword">void</span> **ptr, <span class="keyword">size_t</span> alignment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> **)((<span class="keyword">intptr_t</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ptr + alignment - <span class="number">1</span>) &amp; -alignment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> *<span class="title">MNNMemoryAllocAlign</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment)</span> </span>&#123;</span><br><span class="line">    MNN_ASSERT(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MNN_DEBUG_MEMORY</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">void</span> **origin = (<span class="keyword">void</span> **)<span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) + alignment);</span><br><span class="line">    MNN_ASSERT(origin != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!origin) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **aligned = alignPointer(origin + <span class="number">1</span>, alignment);</span><br><span class="line">    aligned[<span class="number">-1</span>]    = origin;</span><br><span class="line">    <span class="keyword">return</span> aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">MNNMemoryFreeAlign</span><span class="params">(<span class="keyword">void</span> *aligned)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MNN_DEBUG_MEMORY</span></span><br><span class="line">    <span class="built_in">free</span>(aligned);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (aligned) &#123;</span><br><span class="line">        <span class="keyword">void</span> *origin = ((<span class="keyword">void</span> **)aligned)[<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">free</span>(origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析一下以上代码。首先，为了保证内存对齐，我们可以在 <code>malloc</code> 分配时分配比所要求的内存大的内存容量，这样我们可以向下寻找一个保证是对齐大小的整倍数的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> **)<span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) + alignment)</span><br></pre></td></tr></table></figure><p>然后我们向下寻找满足对齐需求的首地址，代码就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> **)((<span class="keyword">intptr_t</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ptr + alignment - <span class="number">1</span>) &amp; -alignment)</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 符号是按位与，<code>-alignment</code> 的补码表示就是 <code>aliginment</code> 符号位不变，其余位按位取反并加 1。我们以 AVX 所需要的 32 bytes 对齐为例，<code>alignment</code> 就是 256，二进制就是 <code>0...00000100000000</code>，<code>-alignment</code> 在计算中的表示就是 <code>1...11111100000000</code>，也就是后 8 位为 0，其余位为均为 1， 因此任何数与 <code>-alignment</code> 按位与的后 8 为都为 0，所以结果肯定是 32 bytes 对齐的。<code>((unsigned char *)ptr + alignment - 1) &amp; -alignment</code> 就相当于把 <code>ptr + alignment - 1</code> 的后 8 位置为 0，这个数比 <code>ptr + alignment - 1</code> 小，而且一定是对齐的。最后将<strong>真正的地址放在对齐后的地址前面，释放的时候取原始的地址及其前面的信息释放内存</strong>。</p><p>通过以上代码，我们可以获取一块在堆上新创建的并且地址对齐的内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C/C++ 编程中常见的一个概念是内存对齐，这里的对齐简单来讲就是分配的内存地址的起始位置是某个数字的倍数。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://murphypei.github.io/tags/C-C/"/>
    
      <category term="内存对齐" scheme="https://murphypei.github.io/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    
      <category term="内存寻址" scheme="https://murphypei.github.io/tags/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
    
      <category term="memory aligin" scheme="https://murphypei.github.io/tags/memory-aligin/"/>
    
  </entry>
  
  <entry>
    <title>最大似然估计和最大后验概率估计</title>
    <link href="https://murphypei.github.io//blog/2020/03/mle-map.html"/>
    <id>https://murphypei.github.io//blog/2020/03/mle-map.html</id>
    <published>2020-03-18T11:38:13.000Z</published>
    <updated>2021-02-20T03:32:19.530Z</updated>
    
    <content type="html"><![CDATA[<p>最大似然估计和最大后验概率估计是概率论中应用很广泛的两个理论，之前的理解似是而非，因此查阅了一些资料，总结记录。</p><a id="more"></a><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><p>最大似然估计（Maximum likelihood estimation, 简称 MLE）是概率论中最常见的应用理论之一，另一个是<a href="https://murphypei.github.io/blog/2020/03/bayes-theorem.html">贝叶斯定理</a>。最大似然估计通俗理解就是<strong>利用已知的样本结果信息，反推最有可能导致这个结果出现的模型参数</strong>。</p><p>换个角度想一想，在机器学习和深度学习任务中，我们学习的是什么？当一个模型确定的时候，我们学习的就是模型的参数啊。<strong>换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。</strong></p><p>似然（likelihood）这个词其实和概率（probability）是差不多的意思，Colins字典这么解释：The likelihood of something happening is how likely it is to happen. 你把 likelihood 换成 probability，这解释也读得通。但是<strong>在统计里面，似然函数和概率函数却是两个不同的概念</strong>（其实也很相近就是了）。</p><p>对于函数  $P(x|\theta)$，输入有两个：$x$ 表示某一个具体的数据，$\theta$ 表示模型的参数。</p><ul><li>如果 $\theta$ 是已知确定的，$x$ 是变量，这个函数就称为概率函数（probability function），它描述对于不同的样本点 $x$，其出现的概率是多少。</li><li>如果 $x$ 是已知确定的，$\theta$ 是变量，这个函数就称为似然函数（likelihood function），它描述对于不同的模型参数，出现 $x$ 这个样本点的概率是多少。</li></ul><blockquote><p>上述的表述看上去似乎在玩文字游戏，但是其实也不难理解，举个抛硬币的例子。</p><p>如果抛一枚硬币出现正面的概率是 0.5（参数确定），则抛 10 次硬币，出现 10 次正面的概率是多少呢？ $0.5^{10}$ ，这就是概率函数。</p><p>如果是抛 10 次硬币出现了 10 次正面，那么什么硬币最可能出现这种情况呢？（参数未知），很明显，硬币不规则，导致出现正面的概率极大，或者说一定会出现正面。这里需要求解的就是抛硬币出现正面的概率。</p></blockquote><p>好了，理解了上述的思想，我们就可以很容易理解最大似然估计，或者说上述的例子其实已经说明了最大似然估计怎么使用。下面对上述抛硬币的例子进行深入解析。</p><p>假设有一个造币厂生产某种硬币，现在我们拿到了一枚这种硬币，想试试这硬币是不是均匀的。即想知道抛这枚硬币，正反面出现的概率（记为 $\theta$ ）各是多少？</p><p>这就是日常中常见的一个需要用统计学习方法解决的实际例子，就是<strong>实际日常中，模型的参数往往都是未知的，但是我们可以通过做统计实验得到观察数据</strong>。</p><p>现在我们拿这枚硬币抛了 10 次，得到的观察数据（记为 $x$ ）是：反正正正正反正正正反。我们想求的正面概率。</p><p>首先假设模型，记住，最大似然估计是在给定模型的情况下估计参数。抛硬币可以假设是一个二项分布，合情合理。那么，出现实验结果 $x_0$（即反正正正正反正正正反）的<strong>似然函数</strong>是多少呢？</p><script type="math/tex; mode=display">f(x, \theta) = (1-\theta) \times \theta \times \theta \times \theta \times \theta \times (1-\theta) \times \theta \times \theta \times \theta \times (1-\theta) = \theta^7(1-\theta)^3 = f(\theta)</script><p>这里要注意，这里 $f$ 是似然函数， $x$ 是已知量，$\theta$ 是未知量，因此是一个关于 $\theta$ 的函数。最大似然估计，顾名思义就是最大化这个函数，我们可以画出 $f(\theta)$ 的图像：</p><p><img src="/images/posts/ml/mle_map/theta_mle.png" alt></p><p>可以看出，在 $\theta=0.7$ 时，似然函数取得最大值。</p><p>这样，我们已经完成了对 $\theta$ 的最大似然估计。即抛 10 次硬币，发现 7 次硬币正面向上，最大似然估计认为正面向上的概率是 0.7，看上去也很符合直觉。</p><p>且慢，一些人可能会说，硬币一般都是均匀的啊！ 就算你做实验发现结果是“反正正正正反正正正反”，我也不信 $\theta = 0.7$，<strong>因为 $\theta=0.7$ 这件事本身比 $\theta=0.5$ 这件事更加难以置信</strong>。为此，我们就需要引入贝叶斯学派的思想了——要考虑先验概率。 为此，引入了<strong>最大后验概率估计</strong>（Maximum a posteriori estimation, 简称MAP）。</p><h3 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a>最大后验概率估计</h3><p>最大似然估计是单纯根据出现的事件求参数 $\theta$，使似然函数 $P(x|\theta)$ 最大。最大后验概率估计在最大似然估计的基础上，求得的 $\theta$ 不仅仅是让似然函数最大，也让 $\theta$ 自己出现的概率最大。我们可以换个角度来思考这个问题，对于不同的 $\theta$ 可以得到不同的似然函数的值，但是 $\theta$ 本身出现的概率可以用来对似然函数进行正则化，让似然函数更加合理，本身出现概率小的 $\theta$ 会引入惩罚，降低其似然函数的值。但是与损失函数中正则化项一般用加法不同，MAP 里利用乘法引入这个惩罚因子。</p><p>MAP 定义是最大化一个函数：</p><script type="math/tex; mode=display">P(\theta|x)=\frac{P(x|\theta)P(\theta)}{P(x)}</script><p>因为 $x$ 是确定的观察事件。因此 $P(x)$ 是已知值，所以可以去掉分母。</p><blockquote><p>假设”投 10 次硬币“是一次实验，实验做了 1000 次，“反正正正正反正正正反”出现了 n 次，则$P(x)=n / 1000$。总之，这是一个可以由实验观察数据集得到的值。</p></blockquote><p>上述的公式是不是很像贝叶斯定理？最大后验概率的名字由来就是最大化 $P(\theta|x)$，这其实是一个后验概率。与似然函数 $P(x|\theta)$ 不同的也仅仅是乘以先验概率 $P(\theta)$。</p><p>先验概率我们可以通过假设一个高斯分布来描述。假设 $P(\theta)$ 为均值 0.5，方差 0.1 的高斯函数（万能的假设函数…），如下图：</p><p><img src="/images/posts/ml/mle_map/theta_gaussian.png" alt></p><p>则 $P(x|\theta)P(\theta)$ 的函数图像是：</p><p><img src="/images/posts/ml/mle_map/theta_map.png" alt></p><p>注意，此时函数取最大值时，$\theta$ 取值已向左偏移，不再是 0.7。实际上，在 $\theta=0.558$ 时函数取得了最大值。即用最大后验概率估计，得到 $θ=0.558$ 。最后，那要怎样才能说服一个贝叶斯派相信 $θ=0.7$ 呢？你得多做点实验，让似然函数更加集中。比如做了1000次实验，其中700次都是正面向上，这时似然函数为：</p><p><img src="/images/posts/ml/mle_map/1000_theta_mle.png" alt></p><p>这样即使乘以先验概率的惩罚项，得到的结果还是 $\theta=0.7$ 最大（实际乘的结果是 0.696，如果还不信，继续加大实验次数）。</p><p>当然，从我们的计算中可以看出，MAP 是同时受先验概率和似然函数的影响，如果先验概率不合理，比如 $P(\theta=0.7)=0$，那么做多少次实验都没有意义了…</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://blog.csdn.net/u011508640/article/details/72815981" target="_blank" rel="noopener">https://blog.csdn.net/u011508640/article/details/72815981</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最大似然估计和最大后验概率估计是概率论中应用很广泛的两个理论，之前的理解似是而非，因此查阅了一些资料，总结记录。&lt;/p&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://murphypei.github.io/categories/MachineLearning/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概率论" scheme="https://murphypei.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
      <category term="最大似然" scheme="https://murphypei.github.io/tags/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6/"/>
    
      <category term="最大后验概率" scheme="https://murphypei.github.io/tags/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯定理</title>
    <link href="https://murphypei.github.io//blog/2020/03/bayes-theorem.html"/>
    <id>https://murphypei.github.io//blog/2020/03/bayes-theorem.html</id>
    <published>2020-03-14T11:38:13.000Z</published>
    <updated>2021-02-20T03:32:19.530Z</updated>
    
    <content type="html"><![CDATA[<p>贝叶斯定理的理解对于概率计算是非常重要，而且日常使用非常常见。</p><a id="more"></a><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们日常计算概率，最简单的就是正向概率。比如一个抽奖活动，抽奖桶里有 10 个球，其中 2 个白球，8 个黑球，抽到白球就算你中奖。你伸手进去随便摸出 1 颗球，摸出中奖球的概率是多大。根据概率计算公式可知是 2/10。</p><p><strong>正向概率是已知事件空间的概率分布，求某个事件发生的概率</strong>，这在日常生活中并不常见，除了抽奖。日常常见的是发生了某件事，比如天上有乌云，我要知道下雨的概率。这类<strong>利用有限的信息预测可能发生的事件概率</strong>在生活中无处不在，也是算法所要解决的问题，而贝叶斯定理解决的是就是这类问题。贝叶斯定理的用处可以总结为一句话：<strong>在有限的信息下，能够帮助我们预测出概率</strong>。</p><h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)}</script><p>在介绍贝叶斯定理之前，简单介绍概率论相关知识点：</p><ul><li>$P(A)$ 表示事件 A 发生的概率。</li><li>$P(AB)$ 表示事件 A 和事件 B 同时发生的概率。</li><li>$P(B|A)$ 表示在事件 A 发生的前提下，事件 B 发生的概率。</li></ul><p>很明显，贝叶斯定理所要求解的问题就是$P(A|B)$ 这种概率，也就是在已知事件 B 的情况下，求事件 A 发生的概率。为此，我们还需要了解一些关于概率的名词。</p><h4 id="先验概率"><a href="#先验概率" class="headerlink" title="先验概率"></a>先验概率</h4><p>$P(A)$ 是先验概率（prior probability），先验概率就是已知的概率分布，比如投一个正常骰子的每个点数的概率是 1/6，抛一枚正常硬币正面和反面的概率都是 1/2。</p><h4 id="可能性函数"><a href="#可能性函数" class="headerlink" title="可能性函数"></a>可能性函数</h4><p>$P(B|A)/P(B)$ 称为“可能性函数”（likelyhood），这是一个调整因子，即新信息 $B$ 带来的调整，作用 是<strong>使得先验概率更接近真实概率</strong>。 可能性函数你可以理解为新信息过来后，对先验概率的一个调整。</p><h4 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h4><p>$P(A|B)$ 是后验概率（posterior probability），即在 B 事件发生之后，我们对 A 事件概率的重新评估，也就是贝叶斯定理求解所期望的更加真实的概率。</p><p>现在我们再看一遍贝叶斯公式，你现在就能明白这个公式背后的最关键思想了： 我们先根据以往的经验预估一个先验概率 $P(A)$，然后加入新的信息（事件 B），这样有了新的信息后，我们对事件 A 的预测就更加准确。 因此，贝叶斯定理可以理解成下面的式子： </p><p><strong>后验概率（新信息出现后的A概率）＝ 先验概率（A概率）ｘ 可能性函数（新信息带来的调整）</strong></p><p>为什么需要像贝叶斯这样做呢？前面已经解释了，一个事件比如下雨，发生的概率是受非常多因素的影响，那么我们如果预测天气呢，其实就是把能够考虑到的信息都计算进去，然后不断修正先验概率，得到后验概率。这里有一个朴素的思想：如果我能掌握一个事情的全部信息，我当然能计算出一个客观概率（古典概率）。但是当我们手中只有有限的信息。既然无法得到全面的信息，我们就在信息有限的情况下，尽可能做出一个好的预测。也就是，在主观判断的基础上，你可以先估计一个值，然后根据观察的新信息不断修正(可能性函数)。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>贝叶斯定理很简单，但是最难的是将简单的公式应用到实际解决问题当中去，这也是对定理深刻的理解。</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><p>假设有两个一模一样的碗，1 号碗里有 30 个巧克力和 10 个水果糖，2 号碗里有 20 个巧克力和 20 个水果糖。现在随机选择一个碗，从里面摸出一个巧克力。 问这颗巧克力来自 1 号碗的概率是多少？</p><p>我们一步步来求解。</p><p>首先把问题分解，问题的事件 A 是要求取的后验概率，因此定义事件 A 就是选择了 1 号碗的概率。而事件 B 是已经发生的事，也就是摸出了一颗巧克力，因此定义事件 B 为取出一个巧克力。所以 $P(A|B)$ 就表示取出一颗巧克力，其来自 1 号碗的概率。。</p><p>现在我们先分别计算 $P(A)$ 和 $P(B)$ 。因为碗一样，所以 $P(A)$ 肯定是 1/2。$P(B)$ 用古典概率分布也很容易求出：</p><script type="math/tex; mode=display">P(B) = 0.5 \times \frac {30} {40} + 0.5 \times \frac {20} {40} = 0.625</script><p>也就是说在未知情况下，取出巧克力的先验概率是 0.625。接着计算 $P(B|A)$ 也很简单，就是确定选择了 1 号碗，取出巧克力的概率很明显是 0.75。因此可能性函数就是：</p><script type="math/tex; mode=display">\frac {P(B|A)} {P(B)} = \frac {0.75} {0.625} = 1.2</script><p>很明显，可能性增强了。表明事件 B 对事件 A 发生的概率产生了增益。其实我们看题目也明白，1 号碗中巧克力的比例更大，因此如果选择了 1 号碗（事件 A）发生，必然取得巧克力（事件 B）的概率也变大了。</p><p>后验概率计算：</p><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)} = 0.5 \times 1.2 = 0.6</script><p>可以看到，如果是盲猜，那么这颗巧克力不是来自 1 号碗就是来自 2 号碗，二者概率均为 0.5。但是运用贝叶斯定理，因为两个碗里的巧克力比例不同，盲猜的先验概率得到了修正，来自 1 号碗的概率更大。这也是符合日常常识的。</p><p>总结下刚才的贝叶斯定理应用的套路：</p><ol><li>首先分解问题，简单来说就像做应用题的感觉，先列出解决这个问题所需要的一些条件，然后记清楚哪些是已知 的，哪些是未知的，已知条件是什么。</li><li>应用贝叶斯定理，求贝叶斯公式中的 2 个指标：先验概率和可能性函数，然后带入贝叶斯公式求后验概率。</li></ol><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><p>假设某种疾病的发病率是 0.001，即 1000 人中会有 1 个人得病。现有一种试剂可以检验患者是否得病，它的准确率是 0.99，即在患者确实得病的情况下，它有 99% 的可能呈现阳性。它的误报率是 5%，即在患者没有得病的情况下，它有 5% 的可能呈现阳性。现有一个病人的检验结果为阳性，请 问他确实得病的可能性有多大？</p><p>我们一步步分解来看。</p><p>已知事件B：检验结果为阳性。求解事件A：确实得病。可以利用古典概率公式分别求二者的概率：</p><script type="math/tex; mode=display">P(B)=0.001 \times 0.99 + (1-0.001) \times 0.05=0.05094</script><p>右边第一项是得病的人，检测结果为阳性，第二项是没病得人，检测结果为阳性。</p><script type="math/tex; mode=display">P(A)=0.001</script><p>$P(B|A)$  就是得病了，检测结果为阳性，很明显就是0.99，因此可能性函数也可以很容易求得：</p><script type="math/tex; mode=display">\frac{P(B|A)}{P(B)} =\frac{0.99}{0.05094}=19.435</script><p>最后运用贝叶斯公式：</p><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)} = 0.001 \times 19.435 = 0.0194</script><p>也就是检测正确率很高的情况下，检测结果成阳性，其真正得病的概率也才 0.0194，这是不是很不符合我们平时的感觉？这就是贝叶斯公式的厉害之处。我们看一下这里问题出在哪里呢？其实很简单，就是真实得病率太低了，虽然检测结果为阳性这个事件已经将其发生概率提升了 19 倍多。这就是为什么医学检查通常要做很多次，特别是像艾滋病这种发病率很低的病。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>贝叶斯定理因为其强大的内在原理和广泛的应用场景，因此成为机器学习的基础，衍生出很多应用方式。其实更厉害的是其思想，也就是分解问题、主观判断、搜集信息、修正判断。这一套逻辑不仅仅是概率，更是日常生活中我们做事情、学习的逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贝叶斯定理的理解对于概率计算是非常重要，而且日常使用非常常见。&lt;/p&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://murphypei.github.io/categories/MachineLearning/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="贝叶斯定理" scheme="https://murphypei.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    
      <category term="概率论" scheme="https://murphypei.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>父类成员函数调用子类成员函数</title>
    <link href="https://murphypei.github.io//blog/2020/03/call-derived-function.html"/>
    <id>https://murphypei.github.io//blog/2020/03/call-derived-function.html</id>
    <published>2020-03-07T11:38:13.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个很有意思的问题，如果在父类成员函数中调用子类成员函数。这个应用场景不是很常见，但是有一些方法可以实现。</p><a id="more"></a><h4 id="通过函数指针"><a href="#通过函数指针" class="headerlink" title="通过函数指针"></a>通过函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明子类对象指针</span></span><br><span class="line">    Derived *d;</span><br><span class="line">    <span class="comment">// 声明子类型的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (Derived::*f)(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过子类型对象和函数指针调用子类型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        (d-&gt;*f)(<span class="number">123</span>); <span class="comment">// 注意调用的写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived f2: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为继承得到的父类型的成员变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        d = <span class="keyword">this</span>;</span><br><span class="line">        f = &amp;Derived::f2;<span class="comment">// 注意这里 &amp; 后面不能加括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.f3();</span><br><span class="line">    d.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived f2: 123</span><br></pre></td></tr></table></figure><p>思路是这样的，在父类中声明子类成员变量指针和函数指针，并在父类成员方法中通过函数指针去调用。然后在子类中给继承得到的这些成员变量赋值，这样子类调用父类的方法的时候就能实现调用子类方法。</p><p>这里说两个关于类成员函数指针的知识点：</p><blockquote><ol><li>函数指针赋值要使用 <strong>&amp;</strong></li><li>使用 <strong>.*</strong> (实例对象)或者 <strong>-&gt;*</strong>（实例对象指针）调用类成员函数指针所指向的函数</li></ol></blockquote><h4 id="通过模板类"><a href="#通过模板类" class="headerlink" title="通过模板类"></a>通过模板类</h4><p>其实这个问题本来是让我用模板类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T *t;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base f1: "</span>&lt;&lt; t-&gt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 模板类型即使看不到声明也可以调用</span></span><br><span class="line">        t-&gt;f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived f2: "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val = <span class="number">123</span>;</span><br><span class="line">        t = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.f3();</span><br><span class="line">    d.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base f1: 123</span><br><span class="line">Derived f2: 123</span><br></pre></td></tr></table></figure><p>其实思路类似，就是在父类中需要有一个占位符能表示子类。在前面函数指针实现中，我们用子类指针和函数指针作为声明（需要前置声明子类）占位符。而利用模板，我们不需要函数指针，模板类型本身就可以作为一种占位符。我们将模板类型当作子类类型，直接在父类成员中调用子类函数。另外，我们在子类定义时，继承的父类是利用子类模板实例化的一个类，然后在子类中给模板类型赋值为当前对象指针，这样就实现了调用。</p><p>其实这里我们主要是利用 t 是模板类型 T 的指针，这样即使不知道 t 的具体定义，也可以访问到其成员，可以调用到其方法，若非通过模板，就不能这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一个很有意思的问题，如果在父类成员函数中调用子类成员函数。这个应用场景不是很常见，但是有一些方法可以实现。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++11" scheme="https://murphypei.github.io/tags/C-11/"/>
    
      <category term="模板" scheme="https://murphypei.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="函数指针" scheme="https://murphypei.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ 右值引用使用总结</title>
    <link href="https://murphypei.github.io//blog/2020/02/right-reference.html"/>
    <id>https://murphypei.github.io//blog/2020/02/right-reference.html</id>
    <published>2020-02-24T11:38:13.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于 C++11 右值引用的一篇总结，觉得其中对于常见误用的总结很不错，想起来了当年自己走过的一些坑，转载做个记录。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>如果你还不知道 C++ 11 引入的右值引用是什么，可以读读这篇文章，看看有什么 <strong>启发</strong>；如果你已经对右值引用了如指掌，也可以读读这篇文章，看看有什么 <strong>补充</strong>。欢迎交流~ </p></blockquote><p>尽管 C++ 17 标准已经发布了，很多人还不熟悉 C++ 11 的 <strong>右值引用/移动语义/拷贝省略/通用引用/完美转发</strong> 等概念，甚至对一些细节 <strong>有所误解</strong>（包括我）。</p><p>本文将以最短的篇幅，一步步解释 关于右值引用的 <strong>为什么/是什么/怎么做</strong>。先分享几个我曾经犯过的错误。</p><h4 id="误解1：返回前，移动局部变量"><a href="#误解1：返回前，移动局部变量" class="headerlink" title="误解1：返回前，移动局部变量"></a>误解1：返回前，移动局部变量</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move" target="_blank" rel="noopener">ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> base_url = tag-&gt;GetBaseUrl();</span><br><span class="line"><span class="keyword">if</span> (!base_url.empty()) &#123;</span><br><span class="line">  UpdateQueryUrl(<span class="built_in">std</span>::move(base_url) + <span class="string">"&amp;q="</span> + word_);</span><br><span class="line">&#125;</span><br><span class="line">LOG(INFO) &lt;&lt; base_url;  <span class="comment">// |base_url| may be moved-from</span></span><br></pre></td></tr></table></figure><p>上述代码的问题在于：使用 <code>std::move()</code> 移动局部变量 <code>base_url</code>，会导致后续代码不能使用该变量；如果使用，会出现 <strong>未定义行为</strong> <em>(undefined behavior)</em>（参考：<a href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string" target="_blank" rel="noopener"><code>std::basic_string(basic_string&amp;&amp;)</code></a>）。</p><p>如何检查 <strong>移动后使用</strong> <em>(use after move)</em>：</p><ul><li>运行时，在 移动构造/移动赋值 函数中，将被移动的值设置为无效状态，并在每次使用前检查有效性</li><li>编译时，使用 Clang 标记对移动语义进行静态检查（参考：<a href="https://clang.llvm.org/docs/AttributeReference.html#consumed-annotation-checking" target="_blank" rel="noopener">Consumed Annotation Checking | Attributes in Clang</a>）</li></ul><h4 id="误解2：被移动的值不能再使用"><a href="#误解2：被移动的值不能再使用" class="headerlink" title="误解2：被移动的值不能再使用"></a>误解2：被移动的值不能再使用</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic" target="_blank" rel="noopener">C.64: A move operation should move and leave its source in a valid state</a></p></blockquote><p>很多人认为：被移动的值会进入一个 <strong>非法状态</strong> <em>(invalid state)</em>，对应的 <strong>内存不能再访问</strong>。</p><p>其实，C++ 标准要求对象 遵守 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> <strong>移动语义</strong> —— 被移动的对象进入一个 <strong>合法但未指定状态</strong> <em>(valid but unspecified state)</em>，调用该对象的方法（包括析构函数）不会出现异常，甚至在重新赋值后可以继续使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">std</span>::move(p);</span><br><span class="line"></span><br><span class="line">assert(p == <span class="literal">nullptr</span>);  <span class="comment">// OK: reset to default</span></span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">2</span>&#125;);   <span class="comment">// or p = std::make_unique&lt;int&gt;(2);</span></span><br><span class="line">assert(*p == <span class="number">2</span>);       <span class="comment">// OK: reset to int*(2)</span></span><br></pre></td></tr></table></figure><p>另外，基本类型（例如 <code>int/double</code>）的移动语义 和拷贝相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">std</span>::move(i);</span><br><span class="line"></span><br><span class="line">assert(i == j);</span><br></pre></td></tr></table></figure><h4 id="误解3：移动非引用返回值"><a href="#误解3：移动非引用返回值" class="headerlink" title="误解3：移动非引用返回值"></a>误解3：移动非引用返回值</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local" target="_blank" rel="noopener">F.48: Don’t <code>return std::move(local)</code></a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; foo() &#123;</span><br><span class="line">  <span class="keyword">auto</span> ret = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(ret);  <span class="comment">// -&gt; return ret;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于：没必要使用 <code>std::move()</code> 移动非引用返回值。</p><p>C++ 会把即将离开作用域的 <strong>非引用类型的</strong> 返回值当成 <strong>右值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#值类别-vs-变量类型" target="_blank" rel="noopener">§ 2.1</a>），对返回的对象进行 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> 移动构造（语言标准）；如果编译器允许 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#拷贝省略" target="_blank" rel="noopener">§ 4</a> 拷贝省略，还可以省略这一步的构造，直接把 <code>ret</code> 存放到返回值的内存里（编译器优化）。</p><blockquote><p>Never apply <code>std::move()</code> or <code>std::forward()</code> to local objects if they would otherwise be eligible for the return value optimization. —— Scott Meyers, <em>Effective Modern C++</em></p></blockquote><p>另外，误用 <code>std::move()</code> 会 <strong>阻止</strong> 编译器的拷贝省略 <strong>优化</strong>。不过聪明的 Clang 会提示 <a href="https://developers.redhat.com/blog/2019/04/12/understanding-when-not-to-stdmove-in-c/" target="_blank" rel="noopener"><code>-Wpessimizing-move</code>/<code>-Wredundant-move</code></a> 警告。</p><h4 id="误解4：不移动右值引用参数"><a href="#误解4：不移动右值引用参数" class="headerlink" title="误解4：不移动右值引用参数"></a>误解4：不移动右值引用参数</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-consume" target="_blank" rel="noopener">F.18: For “will-move-from” parameters, pass by <code>X&amp;&amp;</code> and <code>std::move()</code> the parameter</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; bar(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp;&amp; val) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> val;    <span class="comment">// not compile</span></span><br><span class="line">                 <span class="comment">// -&gt; return std::move/forward(val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于：没有对返回值使用 <code>std::move()</code>（编译器提示 <code>std::unique_ptr(const std::unique_ptr&amp;) = delete</code> 错误）。</p><blockquote><p><a href="http://thbecker.net/articles/rvalue_references/section_05.html#no_name" target="_blank" rel="noopener">If-it-has-a-name Rule</a>:</p><ul><li>Named rvalue references are lvalues.</li><li>Unnamed rvalue references are rvalues.</li></ul></blockquote><p>因为不论 <strong>左值引用</strong> 还是 <strong>右值引用</strong> 的变量（或参数）在初始化后，都是左值（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#值类别-vs-变量类型" target="_blank" rel="noopener">§ 2.1</a>）：</p><ul><li><strong>命名的右值引用</strong> <em>(named rvalue reference)</em> <strong>变量</strong> 是 <strong>左值</strong>，但变量类型却是 <strong>右值引用</strong>。</li><li>在作用域内，<strong>左值变量</strong> 可以通过 <strong>变量名</strong> <em>(variable name)</em> <strong>被取地址、被赋值</strong>。</li></ul><p>所以，返回右值引用变量时，需要使用 <code>std::move()</code>/<code>std::forward()</code> 显式的 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <strong>移动转发</strong> 或 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#完美转发" target="_blank" rel="noopener">§ 5.3</a> <strong>完美转发</strong>，将变量 “还原” 为右值（右值引用类型）。</p><blockquote><p>这里补充一下，这里说的是右值引用的变量，常见于函数的参数，函数参数传递会导致外面的右值引用进入函数内部作为参数变成了左值变量。</p></blockquote><h4 id="误解5：手写错误的移动构造函数"><a href="#误解5：手写错误的移动构造函数" class="headerlink" title="误解5：手写错误的移动构造函数"></a>误解5：手写错误的移动构造函数</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero" target="_blank" rel="noopener">C.20: If you can avoid defining default operations, do</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five" target="_blank" rel="noopener">C.21: If you define or <code>=delete</code> any default operation, define or <code>=delete</code> them all</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eqdefault" target="_blank" rel="noopener">C.80: Use <code>=default</code> if you have to be explicit about using the default semantics</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept" target="_blank" rel="noopener">C.66: Make move operations <code>noexcept</code></a></p></blockquote><p>实际上，多数情况下：</p><ul><li>如果 <strong>没有定义</strong> 拷贝构造/拷贝赋值/移动构造/移动赋值/析构 函数的任何一个，编译器会 <strong>自动生成</strong> 移动构造/移动赋值 函数（<a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_zero" target="_blank" rel="noopener">rule of zero</a>）</li><li>如果 <strong>需要定义</strong> 拷贝构造/拷贝赋值/移动构造/移动赋值/析构 函数的任何一个，不要忘了 移动构造/移动赋值 函数，否则对象会 <strong>不可移动</strong>（<a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_five" target="_blank" rel="noopener">rule of five</a>）</li><li><strong>尽量使用</strong> <code>=default</code> 让编译器生成 移动构造/移动赋值 函数，否则 <strong>容易写错</strong></li><li>如果 <strong>需要自定义</strong> 移动构造/移动赋值 函数，尽量定义为 <code>noexcept</code> 不抛出异常（编译器生成的版本会自动添加），否则 <strong>不能高效</strong> 使用标准库和语言工具</li></ul><p>例如，标准库容器 <code>std::vector</code> 在扩容时，会通过 <a href="https://en.cppreference.com/w/cpp/container/vector/reserve#Exceptions" target="_blank" rel="noopener"><code>std::vector::reserve()</code></a> 重新分配空间，并转移已有元素。如果扩容失败，<code>std::vector</code> 满足 <a href="https://en.cppreference.com/w/cpp/language/exceptions#Exception_safety" target="_blank" rel="noopener"><strong>强异常保证</strong> <em>(strong exception guarantee)</em></a>，可以回滚到失败前的状态。</p><p>为此，<code>std::vector</code> 使用 <a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept" target="_blank" rel="noopener"><code>std::move_if_noexcept()</code></a> 进行元素的转移操作：</p><ul><li>优先 使用 <code>noexcept</code> 移动构造函数（高效；不抛出异常）</li><li>其次 使用 拷贝构造函数（低效；如果异常，可以回滚）</li><li>再次 使用 非 <code>noexcept</code> 移动构造函数（高效；如果异常，<strong>无法回滚</strong>）</li><li>最后 如果 不可拷贝、不可移动，<strong>编译失败</strong></li></ul><p>如果 没有定义移动构造函数或自定义的移动构造函数没有 <code>noexcept</code>，会导致 <code>std::vector</code> 扩容时执行无用的拷贝，<strong>不易发现</strong>。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>之所以会出现上边的误解，往往是因为 C++ 语言的复杂性和使用者对基础知识的掌握程度不匹配。</p><h4 id="值类别-vs-变量类型"><a href="#值类别-vs-变量类型" class="headerlink" title="值类别 vs 变量类型"></a>值类别 vs 变量类型</h4><p><strong>划重点</strong> —— <strong>值</strong> <em>(value)</em> 和 <strong>变量</strong> <em>(variable)</em> 是两个独立的概念：</p><ul><li>值只有 <strong>类别</strong> <em>(category)</em> 的划分，变量 只有 <strong>类型</strong> <em>(type)</em> 的划分 😵</li><li>值不一定拥有 <strong>身份</strong> <em>(identity)</em>，也不一定拥有 变量名（例如 表达式中间结果 <code>i + j + k</code>）</li></ul><p><a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener"><strong>值类别</strong> <em>(value category)</em></a> 可以分为两种：</p><ul><li><strong>左值</strong> <em>(lvalue, left value)</em> 是能被取地址、不能被移动的值</li><li><strong>右值</strong> <em>(rvalue, right value)</em> 是表达式中间结果/函数返回值（可能拥有变量名，也可能没有）</li></ul><blockquote><p>C++ 17 细化了 <code>prvalue/xvalue/lvalue</code> 和 <code>rvalue/glvalue</code> 类别，本文不详细讨论。</p></blockquote><p><a href="https://en.cppreference.com/w/cpp/language/reference" target="_blank" rel="noopener"><strong>引用类型</strong> <em>(reference type)</em></a> 属于一种 <a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener"><strong>变量类型</strong> <em>(variable type)</em></a>，将在 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#左值引用-vs-右值引用-vs-常引用" target="_blank" rel="noopener">§ 2.2</a> 详细讨论。</p><p>在变量 <a href="https://en.cppreference.com/w/cpp/language/initialization" target="_blank" rel="noopener"><strong>初始化</strong> <em>(initialization)</em></a> 时，需要将 <strong>初始值</strong> <em>(initial value)</em> 绑定到变量上；但 <a href="https://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="noopener"><strong>引用类型变量</strong> 的初始化</a> 和其他的值类型（非引用类型）变量不同：</p><ul><li>创建时，<strong>必须显式初始化</strong>（和指针不同，不允许 <strong>空引用</strong> <em>(null reference)</em>；但可能存在 <strong>悬垂引用</strong> <em>(dangling reference)</em>）</li><li>相当于是 其引用的值 的一个 <strong>别名</strong> <em>(alias)</em>（例如，对引用变量的 <strong>赋值运算</strong> <em>(assignment operation)</em> 会赋值到 其引用的值 上）</li><li>一旦绑定了初始值，就 <strong>不能重新绑定</strong> 到其他值上了（和指针不同，赋值运算不能修改引用的指向；而对于 Java/JavaScript 等语言，对引用变量赋值 可以重新绑定）</li></ul><h4 id="左值引用-vs-右值引用-vs-常引用"><a href="#左值引用-vs-右值引用-vs-常引用" class="headerlink" title="左值引用 vs 右值引用 vs 常引用"></a>左值引用 vs 右值引用 vs 常引用</h4><p>引用类型 可以分为两种：</p><ul><li><strong>左值引用</strong> <em>(l-ref, lvalue reference)</em> 用 <code>&amp;</code> 符号引用 左值（但不能引用右值）</li><li><strong>右值引用</strong> <em>(r-ref, rvalue reference)</em> 用 <code>&amp;&amp;</code> 符号引用 右值（也可以移动左值）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;  data)</span></span>;  <span class="comment">// 1, data is l-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;  <span class="comment">// 2, data is r-ref</span></span><br><span class="line">Data   data;</span><br><span class="line"></span><br><span class="line">Data&amp;  data1 = data;             <span class="comment">// OK</span></span><br><span class="line">Data&amp;  data1 = Data&#123;&#125;;           <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;           <span class="comment">// OK</span></span><br><span class="line">Data&amp;&amp; data2 = data;             <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = <span class="built_in">std</span>::move(data);  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">f(data);    <span class="comment">// 1, data is lvalue</span></span><br><span class="line">f(Data&#123;&#125;);  <span class="comment">// 2, data is rvalue</span></span><br><span class="line">f(data1);   <span class="comment">// 1, data1 is l-ref type and lvalue</span></span><br><span class="line">f(data2);   <span class="comment">// 1, data2 is r-ref type but lvalue</span></span><br></pre></td></tr></table></figure><ul><li>左值引用变量 <code>data1</code> 在初始化时，不能绑定右值 <code>Data{}</code></li><li>右值引用变量 <code>data2</code> 在初始化时，不能绑定左值 <code>data</code>，但可以通过 <code>std::move()</code> 将左值 <strong>转为右值引用</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a>）</li><li><strong>右值引用</strong> 变量 <code>data2</code> 被初始化后，在作用域内是 <strong>左值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>），所以匹配 <code>f()</code> 的 <strong>重载 2</strong></li></ul><p>另外，C++ 还支持了 <strong>常引用</strong> <em>(c-ref, const reference)</em>，<strong>同时接受</strong> 左值/右值 进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// data is c-ref</span></span><br><span class="line"></span><br><span class="line">g(data);    <span class="comment">// ok, data is lvalue</span></span><br><span class="line">g(Data&#123;&#125;);  <span class="comment">// ok, data is rvalue</span></span><br></pre></td></tr></table></figure><p>常引用和右值引用 都能接受右值的绑定，有什么区别呢？</p><ul><li>通过 右值引用/常引用 初始化的右值，都可以将 <a href="https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary" target="_blank" rel="noopener"><strong>生命周期扩展</strong> <em>(lifetime extension)</em></a> 到 绑定该右值的 引用的生命周期</li><li>初始化时 绑定了右值后，右值引用 <strong>可以修改</strong> 引用的右值，而 常引用 不能修改</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Data&amp; data1 = Data&#123;&#125;;   <span class="comment">// OK: extend lifetime</span></span><br><span class="line">data1.modify();               <span class="comment">// not compile: const</span></span><br><span class="line"></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;        <span class="comment">// OK: extend lifetime</span></span><br><span class="line">data2.modify();               <span class="comment">// OK: non-const</span></span><br></pre></td></tr></table></figure><h4 id="引用参数重载优先级"><a href="#引用参数重载优先级" class="headerlink" title="引用参数重载优先级"></a>引用参数重载优先级</h4><p>如果函数重载同时接受 右值引用/常引用 参数，编译器 <strong>优先重载</strong> 右值引用参数 —— 是 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> 移动语义 的实现基础：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// 1, data is c-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;       <span class="comment">// 2, data is r-ref</span></span><br><span class="line"></span><br><span class="line">f(Data&#123;&#125;);  <span class="comment">// 2, prefer 2 over 1 for rvalue</span></span><br></pre></td></tr></table></figure><p>针对不同左右值 <strong>实参</strong> <em>(argument)</em> 重载 引用类型 <strong>形参</strong> <em>(parameter)</em> 的优先级如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">实参/形参</th><th style="text-align:center">T&amp;</th><th style="text-align:center">const T&amp;</th><th style="text-align:center">T&amp;&amp;</th><th style="text-align:center">const T&amp;&amp;</th></tr></thead><tbody><tr><td style="text-align:center">lvalue</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">const lvalue</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">rvalue</td><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">const rvalue</td><td style="text-align:center"></td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">1</td></tr></tbody></table></div><ul><li>数值越小，优先级越高；如果不存在，则重载失败</li><li>如果同时存在 <strong>传值</strong> <em>(by value)</em> 重载（接受值类型参数 <code>T</code>），会和上述 <strong>传引用</strong> <em>(by reference)</em> 重载产生歧义，编译失败</li><li><strong>常右值引用</strong> <em>(const rvalue reference)</em> <code>const T&amp;&amp;</code> 一般不直接使用（<a href="https://codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/" target="_blank" rel="noopener">参考</a>）</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><p><a href="https://en.cppreference.com/w/cpp/language/reference#Reference_collapsing" target="_blank" rel="noopener"><strong>引用折叠</strong> <em>(reference collapsing)</em></a> 是 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 和 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#完美转发" target="_blank" rel="noopener">§ 5.3</a> <code>std::forward()</code> 的实现基础：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Lref = Data&amp;;</span><br><span class="line"><span class="keyword">using</span> Rref = Data&amp;&amp;;</span><br><span class="line">Data data;</span><br><span class="line"></span><br><span class="line">Lref&amp;  r1 = data;    <span class="comment">// r1 is Data&amp;</span></span><br><span class="line">Lref&amp;&amp; r2 = data;    <span class="comment">// r2 is Data&amp;</span></span><br><span class="line">Rref&amp;  r3 = data;    <span class="comment">// r3 is Data&amp;</span></span><br><span class="line">Rref&amp;&amp; r4 = Data&#123;&#125;;  <span class="comment">// r4 is Data&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>在 C++ 11 强化了左右值概念后，提出了 <strong>移动语义</strong> <em>(move semantic)</em> 优化：由于右值对象一般是临时对象，在移动时，对象包含的资源 <strong>不需要先拷贝再删除</strong>，只需要直接 <strong>从旧对象移动到新对象</strong>。</p><p>同时，要求 <strong>被移动的对象</strong> 处于 <strong>合法但未指定状态</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-被移动的值不能再使用" target="_blank" rel="noopener">§ 1.2</a>）：</p><ul><li>（基本要求）能正确析构（不会重复释放已经被移动了的资源，例如 <code>std::unique_ptr::~unique_ptr()</code> 检查指针是否需要 <code>delete</code>）</li><li>（一般要求）重新赋值后，和新的对象没有差别（C++ 标准库基于这个假设）</li><li>（更高要求）恢复为默认值（例如 <code>std::unique_ptr</code> 恢复为 <code>nullptr</code>）</li></ul><p>由于<strong>基本类型不包含资源，其移动和拷贝相同：被移动后，保持为原有值</strong>。</p><h4 id="避免先拷贝再释放资源"><a href="#避免先拷贝再释放资源" class="headerlink" title="避免先拷贝再释放资源"></a>避免先拷贝再释放资源</h4><p>一般通过 <strong>重载构造/赋值函数</strong> 实现移动语义。例如，<code>std::vector</code> 有：</p><ul><li>以常引用作为参数的 <strong>拷贝构造函数</strong> <em>(copy constructor)</em></li><li>以右值引用作为参数的 <strong>移动构造函数</strong> <em>(move constructor)</em></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; rhs);      <span class="comment">// copy data</span></span><br><span class="line">  <span class="built_in">vector</span>(<span class="built_in">vector</span>&amp;&amp; rhs) <span class="keyword">noexcept</span>;  <span class="comment">// move data</span></span><br><span class="line">  ~<span class="built_in">vector</span>();                      <span class="comment">// dtor</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">size_t</span> size_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::<span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; rhs) : data_(<span class="keyword">new</span> T[rhs.size_]) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  <span class="built_in">std</span>::copy_n(rhs.data_, rhs.size_, lhs.data_);  <span class="comment">// copy data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::<span class="built_in">vector</span>(<span class="built_in">vector</span>&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  lhs.data_ = rhs.data_;  <span class="comment">// move data</span></span><br><span class="line">  rhs.size_ = <span class="number">0</span>;</span><br><span class="line">  rhs.data_ = <span class="literal">nullptr</span>;    <span class="comment">// set data of rhs to null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::~<span class="built_in">vector</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (data_)              <span class="comment">// release only if owned</span></span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，构造函数 <code>vector::vector()</code> 根据实参判断（重载优先级参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#引用参数重载优先级" target="_blank" rel="noopener">§ 2.3</a>）：</p><ul><li>实参为左值时，拷贝构造，使用 <code>new[]</code>/<code>std::copy_n</code> 拷贝原对象的所有元素（本方案有一次冗余的默认构造，仅用于演示）。</li><li>实参为右值时，移动构造，把指向原对象内存的指针 <code>data_</code>、内存大小 <code>size_</code> 拷贝到新对象，并把原对象这两个成员置 <code>0</code>。</li></ul><p>析构函数 <code>vector::~vector()</code> 检查 data_ 是否有效，决定是否需要释放资源。</p><blockquote><p>此处省略 拷贝赋值/移动赋值 函数，但建议加上。（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-手写错误的移动构造函数" target="_blank" rel="noopener">§ 1.5</a>）</p></blockquote><p>此外，<strong>类的成员函数</strong> 还可以通过 <a href="https://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions" target="_blank" rel="noopener"><strong>引用限定符</strong> <em>(reference qualifier)</em></a>，针对当前对象本身的左右值状态（以及 const-volatile）重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Data <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::move(data_); &#125;  <span class="comment">// rvalue, move-out</span></span><br><span class="line">  <span class="function">Data <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span>&amp; </span>&#123; <span class="keyword">return</span> data_; &#125;         <span class="comment">// otherwise, copy</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret1 = foo.data();    <span class="comment">// foo   is lvalue, copy</span></span><br><span class="line"><span class="keyword">auto</span> ret2 = Foo&#123;&#125;.data();  <span class="comment">// Foo&#123;&#125; is rvalue, move</span></span><br></pre></td></tr></table></figure><h4 id="转移不可拷贝的资源"><a href="#转移不可拷贝的资源" class="headerlink" title="转移不可拷贝的资源"></a>转移不可拷贝的资源</h4><blockquote><p>在之前写的 <a href="https://bot-man-jl.github.io/articles/?post=2018/Resource-Management#资源和对象的映射关系" target="_blank" rel="noopener">资源管理小记</a> 提到：如果资源是 <strong>不可拷贝</strong> <em>(non-copyable)</em> 的，那么装载资源的对象也应该是不可拷贝的。</p></blockquote><p>如果资源对象不可拷贝，一般需要定义 移动构造/移动赋值 函数，并禁用 拷贝构造/拷贝赋值 函数。例如，智能指针 <code>std::unique_ptr</code> <strong>只能移动</strong> <em>(move only)</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs) <span class="keyword">noexcept</span>;  <span class="comment">// move only</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>::<span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.data_ = rhs.data_;</span><br><span class="line">  rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>unique_ptr</code> 的移动构造过程和 <code>vector</code> 类似：</p><ul><li>把指向原对象内存的指针 <code>data_</code> 拷贝到新对象</li><li>把原对象的指针 <code>data_</code> 置为空</li></ul><h4 id="反例：不遵守移动语义"><a href="#反例：不遵守移动语义" class="headerlink" title="反例：不遵守移动语义"></a>反例：不遵守移动语义</h4><p>移动语义只是语言上的一个 <strong>概念</strong>，具体是否移动对象的资源、如何移动对象的资源，都需要通过编写代码 <strong>实现</strong>。而移动语义常常被 <strong>误认为</strong>，编译器 <strong>自动生成</strong> 移动对象本身的代码（<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#拷贝省略" target="_blank" rel="noopener">§ 4</a> 拷贝省略）。</p><p>为了证明这一点，我们可以实现不遵守移动语义的 <code>bad_vec::bad_vec(bad_vec&amp;&amp; rhs)</code>，执行拷贝语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bad_vec::bad_vec(bad_vec&amp;&amp; rhs) : data_(<span class="keyword">new</span> T[rhs.size_]) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  <span class="built_in">std</span>::copy_n(rhs.data_, rhs.size_, lhs.data_);  <span class="comment">// copy data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，一个 <code>bad_vec</code> 对象在被 <code>move</code> 移动后仍然可用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bad_vec&lt;<span class="keyword">int</span>&gt; v_old &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> v_new = <span class="built_in">std</span>::move(v_old);</span><br><span class="line"></span><br><span class="line">v_old[<span class="number">0</span>] = v_new[<span class="number">3</span>];           <span class="comment">// ok, but odd :-)</span></span><br><span class="line">assert(v_old[<span class="number">0</span>] != v_new[<span class="number">0</span>]);</span><br><span class="line">assert(v_old[<span class="number">0</span>] == v_new[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>虽然代码可以那么写，但是在语义上有问题：进行了拷贝操作，违背了移动语义的初衷。</p><h3 id="拷贝省略"><a href="#拷贝省略" class="headerlink" title="拷贝省略"></a>拷贝省略</h3><p>尽管 C++ 引入了移动语义，移动的过程 仍有优化的空间 —— 与其调用一次 没有意义的移动构造函数，不如让编译器 直接跳过这个过程 —— 于是就有了 <a href="https://en.cppreference.com/w/cpp/language/copy_elision" target="_blank" rel="noopener">拷贝省略 <em>(copy elision)</em></a>。</p><p>然而，很多人会把移动语义和拷贝省略 <strong>混淆</strong>：</p><ul><li>移动语义是 <strong>语言标准</strong> 提出的概念，通过编写遵守移动语义的 移动构造函数、右值限定成员函数，<strong>逻辑上</strong> 优化 <strong>对象内资源</strong> 的转移流程</li><li>拷贝省略是（C++ 17 前）非标准的 <strong>编译器优化</strong>，跳过移动/拷贝构造函数，让编译器直接在 <strong>移动后的对象</strong> 内存上，构造 <strong>被移动的对象</strong>（例如 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-移动非引用返回值" target="_blank" rel="noopener">§ 1.3</a> 的代码，直接在 函数返回值对象 的内存上，构造 函数局部对象 <code>ret</code> —— 在 <strong>不同作用域</strong> 里，共享 <strong>同一块内存</strong>）</li></ul><p>C++ 17 要求编译器对 <strong>纯右值</strong> <em>(prvalue, pure rvalue)</em> 进行拷贝省略优化。（<a href="https://jonasdevlieghere.com/guaranteed-copy-elision/" target="_blank" rel="noopener">参考</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Data <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Data val;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">throw</span> val;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NRVO from lvalue to ret (not guaranteed)</span></span><br><span class="line">  <span class="comment">// if NRVO is disabled, move ctor is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Date arg)</span></span>;</span><br><span class="line"></span><br><span class="line">Data v = f();     <span class="comment">// copy elision from prvalue (C++ 17)</span></span><br><span class="line">g(f());           <span class="comment">// copy elision from prvalue (C++ 17)</span></span><br></pre></td></tr></table></figure><p>初始化 局部变量、函数参数时，传入的纯右值可以确保被优化 —— Return Value Optimization <em>(RVO)</em>；而返回的 <strong>将亡值</strong> <em>(xvalue, eXpiring value)</em> 不保证被优化 —— Named Return Value Optimization <em>(NRVO)</em>。</p><h3 id="通用引用和完美转发"><a href="#通用引用和完美转发" class="headerlink" title="通用引用和完美转发"></a>通用引用和完美转发</h3><blockquote><p>揭示 <code>std::move()</code>/<code>std::forward()</code> 的原理，需要读者有一定的 <strong>模板编程基础</strong>。</p></blockquote><h4 id="为什么需要通用引用"><a href="#为什么需要通用引用" class="headerlink" title="为什么需要通用引用"></a>为什么需要通用引用</h4><p>C++ 11 引入了变长模板的概念，允许向模板参数里传入不同类型的不定长引用参数。由于每个类型可能是左值引用或右值引用，针对所有可能的左右值引用组合，<strong>特化所有模板</strong> 是 <strong>不现实的</strong>。</p><p><strong>假设没有</strong> 通用引用的概念，模板 <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique" target="_blank" rel="noopener"><code>std::make_unique&lt;&gt;</code></a> 至少需要两个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(<span class="keyword">const</span> Args&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; args... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; <span class="built_in">std</span>::move&lt;Args&gt;(args)... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于传入的左值引用 <code>const Args&amp;... args</code>，只要展开 <code>args...</code> 就可以转发这一组左值引用</li><li>对于传入的右值引用 <code>Args&amp;&amp;... args</code>，需要通过 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 转发出去，即 <code>std::move(args)...</code>（为什么要转发：参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>）</li></ul><p>上述代码的问题在于：如果传入的 <code>args</code> <strong>既有</strong> 左值引用 <strong>又有</strong> 右值引用，那么这两个模板都 <strong>无法匹配</strong>。</p><h4 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h4><blockquote><p>Item 24: Distinguish universal references from rvalue references. —— Scott Meyers, <em>Effective Modern C++</em></p></blockquote><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers" target="_blank" rel="noopener">Scott Meyers 指出</a>：有时候符号 <code>&amp;&amp;</code> 并不一定代表右值引用，它也可能是左值引用 —— 如果一个引用符号需要通过 左右值类型推导（模板参数类型 或 <code>auto</code> 推导），那么这个符号可能是左值引用或右值引用 —— 这叫做 <strong>通用引用</strong> <em>(universal reference)</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rvalue ref: no type deduction</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Widget&amp;&amp; param1)</span></span>;</span><br><span class="line">Widget&amp;&amp; var1 = Widget();</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// universal ref: type deduction</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>上述代码中，前三个 <code>&amp;&amp;</code> 符号不涉及引用符号的左右值类型推导，都是右值引用；而后两个 <code>&amp;&amp;</code> 符号会 <strong>根据初始值推导左右值类型</strong>：</p><ul><li>对于 <code>var2</code>，因为 <code>var1</code> 是左值，所以 <code>var2</code> 也是左值引用<ul><li>推导不会参考 <code>var1</code> 的变量类型</li></ul></li><li>对于 <code>T&amp;&amp;</code>：<ul><li>如果 <code>param</code> 传入左值，<code>T&amp;&amp;</code> 是左值引用 <code>std::remove_reference_t&amp;</code></li><li>如果 <code>param</code> 传入右值，<code>T&amp;&amp;</code> 是右值引用 <code>std::remove_reference_t&amp;&amp;</code></li></ul></li></ul><p>基于通用引用，<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#为什么需要通用引用" target="_blank" rel="noopener">§ 5.1</a> 的模板 <code>std::make_unique&lt;&gt;</code> 只需要一个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; <span class="built_in">std</span>::forward&lt;Args&gt;(args)... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>std::forward()</code> 实现了 <strong>针对不同左右值参数的转发</strong> —— 完美转发。</p><blockquote><p>这里就是完美转发真正的意义所在，会将形参的引用类型转发出去。</p></blockquote><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>什么是 <strong>完美转发</strong> <em>(perfect forwarding)</em>：</p><ul><li>如果参数是 <strong>左值引用</strong>，直接以 <strong>左值引用</strong> 的形式，转发给下一个函数</li><li>如果参数是 <strong>右值引用</strong>，要先 “还原” 为 <strong>右值引用</strong> 的形式，再转发给下一个函数</li></ul><p>因此，<a href="https://en.cppreference.com/w/cpp/utility/forward" target="_blank" rel="noopener"><code>std::forward()</code></a> 定义两个 <strong>不涉及</strong> 左右值类型 <strong>推导</strong> 的模板（不能使用 通用引用参数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; val)</span> <span class="keyword">noexcept</span> </span>&#123;  <span class="comment">// #1</span></span><br><span class="line">  <span class="comment">// forward lvalue as either lvalue or rvalue</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp; val)</span> <span class="keyword">noexcept</span> </span>&#123;  <span class="comment">// #2</span></span><br><span class="line">  <span class="comment">// forward rvalue as rvalue (not lvalue)</span></span><br><span class="line">  <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference_v&lt;T&gt;,</span><br><span class="line">                <span class="string">"Cannot forward rvalue as lvalue."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">实参/返回值</th><th style="text-align:center">重载</th><th style="text-align:center">l-ref 返回值</th><th style="text-align:center">r-ref 返回值</th></tr></thead><tbody><tr><td style="text-align:center">l-ref 实参</td><td style="text-align:center">#1</td><td style="text-align:center">完美转发</td><td style="text-align:center"><strong>移动转发</strong></td></tr><tr><td style="text-align:center">r-ref 实参</td><td style="text-align:center">#2</td><td style="text-align:center"><strong>语义错误</strong></td><td style="text-align:center">完美转发</td></tr></tbody></table></div><ul><li>尽管初始化后的变量都是 <strong>左值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>），但原始的 <strong>变量类型</strong> 仍会保留</li><li>因此，可以根据 <strong>实参类型</strong> 选择重载，<strong>和模板参数 <code>T</code> 的类型无关</strong></li><li><strong>返回值类型</strong> <code>static_cast(val)</code> 经过模板参数 <code>T&amp;&amp;</code> <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#引用折叠" target="_blank" rel="noopener">§ 2.4</a> 引用折叠 实现 完美转发/移动转发，<strong>和实参类型无关</strong></li><li>“将 l-ref 实参 转发为 r-ref 返回值” 等价于 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 移动转发</li></ul><h4 id="移动转发"><a href="#移动转发" class="headerlink" title="移动转发"></a>移动转发</h4><p>类似的，<a href="https://en.cppreference.com/w/cpp/utility/move" target="_blank" rel="noopener"><code>std::move()</code></a> 只转发为右值引用类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp; move(T&amp;&amp; val) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// forward either lvalue or rvalue as rvalue</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">实参/返回值</th><th style="text-align:center">r-ref 返回值</th></tr></thead><tbody><tr><td style="text-align:center">l-ref 实参</td><td style="text-align:center">移动转发</td></tr><tr><td style="text-align:center">r-ref 实参</td><td style="text-align:center">移动转发（完美转发）</td></tr></tbody></table></div><ul><li>接受 通用引用模板参数 <code>T&amp;&amp;</code>（无需两个模板，使用时不区分 <code>T</code> 的引用类型）</li><li>返回值 <code>static_cast&amp;&amp;&gt;(val)</code> 将实参 <strong>转为将亡值</strong>（右值引用类型）</li><li>所以 <code>std::move()</code> 等价于 <code>std::forward&amp;&amp;&gt;()</code></li></ul><p>最后，<code>std::move()</code>/<code>std::forward()</code> 只是编译时的变量类型转换，不会产生目标代码。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>原文链接：<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference" target="_blank" rel="noopener">https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇关于 C++11 右值引用的一篇总结，觉得其中对于常见误用的总结很不错，想起来了当年自己走过的一些坑，转载做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++11" scheme="https://murphypei.github.io/tags/C-11/"/>
    
      <category term="右值引用" scheme="https://murphypei.github.io/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="移动" scheme="https://murphypei.github.io/tags/%E7%A7%BB%E5%8A%A8/"/>
    
      <category term="完美转发" scheme="https://murphypei.github.io/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++11 thread_local 用法</title>
    <link href="https://murphypei.github.io//blog/2020/02/thread-local.html"/>
    <id>https://murphypei.github.io//blog/2020/02/thread-local.html</id>
    <published>2020-02-21T05:34:19.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>thread_local 是 C++11 为线程安全引进的变量声明符。</p><a id="more"></a><h3 id="thread-local-简介"><a href="#thread-local-简介" class="headerlink" title="thread_local 简介"></a>thread_local 简介</h3><p>thread_local 是一个<a href="https://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">存储器指定符</a>。</p><blockquote><p>所谓存储器指定符，其作用类似命名空间，指定了变量名的存储期以及链接方式。同类型的关键字还有：</p><ul><li>auto：自动存储期；</li><li>register：自动存储期，提示编译器将此变量置于寄存器中；</li><li>static：静态或线程存储期，同时提示是内部链接；</li><li>extern：静态或线程存储期，同时提示是外部链接；</li><li>thread_local：线程存储期；</li><li>mutable：不影响存储期或链接。</li></ul></blockquote><p>对于 thread_local，官方解释是：</p><blockquote><p><em>thread_local</em> 关键词只对声明于命名空间作用域的对象、声明于块作用域的对象及静态数据成员允许。它指示对象拥有线程存储期。它能与 static 或 extern 结合，以分别指定内部或外部链接（除了静态数据成员始终拥有外部链接），但<strong>附加的 static 不影响存储期</strong>。</p><p><strong>线程存储期</strong>: 对象的存储在线程开始时分配，而在线程结束时解分配。每个线程拥有其自身的对象实例。唯有声明为 thread_local 的对象拥有此存储期。 thread_local 能与 static 或 extern 一同出现，以调整链接。</p></blockquote><p>这里有一个很重要的信息，就是 <strong><code>static thread_local</code> 和 <code>thread_local</code> 声明是等价的</strong>，都是指定变量的周期是在线程内部，并且是静态的。这是什么意思呢？举个代码的例子。</p><p>下面是一个线程安全的均匀分布随机数生成，例子来源于 <a href="https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers" target="_blank" rel="noopener">stackoverflow</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">random_uniform_float</span><span class="params">(<span class="keyword">float</span> *<span class="keyword">const</span> dst, <span class="keyword">const</span> <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">int</span> min = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// generator is only created once in per thread, but distribution can be regenerated.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="built_in">std</span>::default_random_engine generator;     <span class="comment">// heavy</span></span><br><span class="line">    <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; distribution(min, max); <span class="comment">// light</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = distribution(generator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 是一个函数的静态变量，理论上这个静态变量在函数的所有调用期间都是同一个的（静态存储期），相反 <code>distribution</code> 是每次调用生成的函数内临时变量。现在 <code>generator</code> 被 thread_local 修饰，表示其存储周期从整个函数调用变为了线程存储期，也就是在同一个线程内，这个变量表现的就和函数静态变量一样，但是不同线程中是不同的。可以理解为 thread_local 缩小了变量的存储周期。关于 thread_local 变量自动 static，C++ 标准中也有说明：</p><blockquote><p>When thread_local is applied to a variable of block scope the storage-class-specifier static <strong>is implied</strong> if it does not appear explicitly</p></blockquote><p>关于 thread_local 的定义我也不想过多着墨，还是看代码例子说明吧。</p><h3 id="thread-local-使用示例"><a href="#thread-local-使用示例" class="headerlink" title="thread_local 使用示例"></a>thread_local 使用示例</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;    <span class="comment">//方便多线程打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = 2</span><br><span class="line">thread[t2]: x = 3</span><br><span class="line">thread[t2]: x = 4</span><br><span class="line">thread[t1]: x = 2</span><br><span class="line">thread[t1]: x = 3</span><br><span class="line">thread[t1]: x = 4</span><br></pre></td></tr></table></figure><p><strong>可以看出全局的 thread_local 变量在每个线程里是分别自加互不干扰的。</strong></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;    <span class="comment">//方便多线程打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = 2</span><br><span class="line">thread[t2]: x = 3</span><br><span class="line">thread[t2]: x = 4</span><br><span class="line">thread[t1]: x = 2</span><br><span class="line">thread[t1]: x = 3</span><br><span class="line">thread[t1]: x = 4</span><br></pre></td></tr></table></figure><p>可以看到虽然是局部变量，但是在每个线程的每次 for 循环中，使用的都是线程中的同一个变量，也侧面印证了 <strong>thread_local 变量会自动 static</strong>。</p><p>如果我们不加 thread_local，输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>体现了局部变量的特征。</p><p>这里还有一个要注意的地方，就是 <strong>thread_local 虽然改变了变量的存储周期，但是并没有改变变量的使用周期或者说作用域</strong>，比如上述的局部变量，其使用范围不能超过 for 循环外部，否则编译出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x++;    <span class="comment">//编译会出错：error: ‘x’ was not declared in this scope</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroy A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> A* a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: a.counter:"</span> &lt;&lt; a-&gt;get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">2</span></span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看出类对象的使用和创建和内部类型类似，都不会创建多个。这种情况在函数间或通过函数返回实例也是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A* <span class="title">creatA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopin_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> A* a = creatA();</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: a.counter:"</span> &lt;&lt; a-&gt;get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;    </span><br><span class="line">        loopin_func(thread_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:0</span><br><span class="line">thread[t1]: a.counter:1</span><br><span class="line">thread[t1]: a.counter:2</span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:0</span><br><span class="line">thread[t2]: a.counter:1</span><br><span class="line">thread[t2]: a.counter:2</span><br></pre></td></tr></table></figure><p>虽然 <code>createA()</code> 看上去被调用了多次，实际上只被调用了一次，因为 thread_local 变量只会在每个<strong>线程最开始被调用的时候进行初始化，并且只会被初始化一次</strong>。</p><p>举一反三，如果不是初始化，而是赋值，则情况就不同了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void loopin_func(const std::string&amp; thread_name) &#123;</span><br><span class="line">    thread_local A* a;</span><br><span class="line">    a = creatA();</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; thread_name &lt;&lt; &quot;]: a.counter:&quot; &lt;&lt; a-&gt;get_value() &lt;&lt; std::endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">2</span></span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>很明显，虽然只初始化一次，但却可以被多次赋值，因此 C++ 变量初始化是十分重要的（手动狗头）。</p><h4 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h4><p>规定：<strong>thread_local 作为类成员变量时必须是 static 的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;&#125;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> <span class="keyword">int</span> b_key;</span><br><span class="line">    <span class="comment">//thread_local int b_key;</span></span><br><span class="line">    <span class="keyword">int</span> b_value = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b_static;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> B::b_key = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> B::b_static = <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        b.b_key--;</span><br><span class="line">        b.b_value--;</span><br><span class="line">        b.b_static--;   <span class="comment">// not thread safe</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: b_key:"</span> &lt;&lt; b.b_key &lt;&lt; <span class="string">", b_value:"</span> &lt;&lt; b.b_value &lt;&lt; <span class="string">", b_static:"</span> &lt;&lt; b.b_static &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: B::key:"</span> &lt;&lt; B::b_key &lt;&lt; <span class="string">", b_value:"</span> &lt;&lt; b.b_value &lt;&lt; <span class="string">", b_static: "</span> &lt;&lt; B::b_static &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create B</span><br><span class="line">thread[t2]: b_key:11, b_value:23, b_static:35</span><br><span class="line">thread[t2]: B::key:11, b_value:23, b_static: 35</span><br><span class="line">thread[t2]: b_key:10, b_value:22, b_static:34</span><br><span class="line">thread[t2]: B::key:10, b_value:22, b_static: 34</span><br><span class="line">thread[t2]: b_key:9, b_value:21, b_static:33</span><br><span class="line">thread[t2]: B::key:9, b_value:21, b_static: 33</span><br><span class="line">create B</span><br><span class="line">thread[t1]: b_key:11, b_value:23, b_static:32</span><br><span class="line">thread[t1]: B::key:11, b_value:23, b_static: 32</span><br><span class="line">thread[t1]: b_key:10, b_value:22, b_static:31</span><br><span class="line">thread[t1]: B::key:10, b_value:22, b_static: 31</span><br><span class="line">thread[t1]: b_key:9, b_value:21, b_static:30</span><br><span class="line">thread[t1]: B::key:9, b_value:21, b_static: 30</span><br></pre></td></tr></table></figure><p><code>b_key</code> 是 thread_local，虽然其也是 static 的，但是每个线程中有一个，每次线程中的所有调用共享这个变量。<code>b_static</code> 是真正的 static，全局只有一个，所有线程共享这个变量。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/storage_duration</a></li><li><a href="https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers" target="_blank" rel="noopener">https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers</a></li><li><a href="http://cifangyiquan.net/programming/thread_local/" target="_blank" rel="noopener">http://cifangyiquan.net/programming/thread_local/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;thread_local 是 C++11 为线程安全引进的变量声明符。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="thread" scheme="https://murphypei.github.io/tags/thread/"/>
    
      <category term="static" scheme="https://murphypei.github.io/tags/static/"/>
    
      <category term="thread_local" scheme="https://murphypei.github.io/tags/thread-local/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下 shadowsocks 使用配置</title>
    <link href="https://murphypei.github.io//blog/2020/02/linux-shadowsocks-config.html"/>
    <id>https://murphypei.github.io//blog/2020/02/linux-shadowsocks-config.html</id>
    <published>2020-02-10T03:43:08.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Linux 使用 shadowsocks 的方法。</p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>创建配置文件： <code>/etc/shadowsocks.json</code></p><p>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"1.2.3.4", // 服务器IP</span><br><span class="line">    "server_port":8888, // 对外提供服务的端口</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"your password",</span><br><span class="line">    "timeout":600,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast-open": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作为服务器"><a href="#作为服务器" class="headerlink" title="作为服务器"></a>作为服务器</h4><p>前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop # 停止</span><br></pre></td></tr></table></figure><h4 id="作为客户端"><a href="#作为客户端" class="headerlink" title="作为客户端"></a>作为客户端</h4><p>前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">sslocal -c /etc/shadowsocks.json -d stop # 停止</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Linux 使用 shadowsocks 的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://murphypei.github.io/tags/Linux/"/>
    
      <category term="shadowsocks" scheme="https://murphypei.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 启动过程中各配置脚本执行顺序</title>
    <link href="https://murphypei.github.io//blog/2020/02/linux-startup-scripts.html"/>
    <id>https://murphypei.github.io//blog/2020/02/linux-startup-scripts.html</id>
    <published>2020-02-10T02:58:25.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>登录 Linux 时，会有 <code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>等相关配置文件依次启动，本文以 Ubuntu 为例说明。</p><a id="more"></a><p>对于 Ubuntu 而言，系统登录时会读取 <code>/etc/profile</code> 的内容。</p><p>在 <code>/etc/profile</code> 文件中会启动 <code>/etc/bash.bashrc</code>，然后遍历 <code>/etc/profile.d</code> 文件夹，启动里面的每一个 sh 文件。</p><p>然后执行 <code>~/.bash_profile</code> 或者 <code>~/.bash_login</code> 或者 <code>~/.profile</code> 中的一个，他们的执行优先级为 bash_profile&gt;bash_login&gt;profile。</p><p>当我们在终端打开一个 shell（包括打开一个新终端和在终端上输入bash），都会重新读取和 <code>~/.bashrc</code> 文件里面的内容。</p><p>使用 login 和 non login 术语来说，就是使用 login 方式是会读取 <code>/etc/profile</code> 和 <code>~/.profile</code> 文件。使用 non login 方式的话，会读取 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code> 文件的内容。也就是说 <code>/etc/profile</code> 和 <code>~/.profile</code> 文件是在 login 时才会读取。所以，在不使用 su 命令的情况下，只有在 Linux 启动登录的时候才会被读取（这也就导致了有些软件安装后，要重启才能生效）。</p><blockquote><p>login 模式是指用户通过 /bin/login 登录进系统然后启动 shell，而 non login 模式是指由某些程序启动的 shell，比如 /bin/bash。</p></blockquote><p>在退出登录时会执行 <code>~/.bash_logout</code>。</p><p>因此各脚本执行顺序为：<code>/etc/profile</code> -&gt; (<code>~/.bash_profile</code> | <code>~/.bash_login</code> | <code>~/.profile</code>) -&gt; <code>~/.bashrc</code> -&gt; <code>~/.bash_logout</code>。</p><p>关于各个文件的作用域，在网上找到了以下说明：</p><ul><li><code>/etc/profile</code>： 此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，<strong>该文件仅仅执行一次</strong>。并从 <code>/etc/profile.d</code> 目录的配置文件中搜集 shell 的设置。</li><li><code>/etc/bash.bashrc</code>：为每一个运行 bash shell 的用户执行此文件.当 bash shell 被打开时，该文件被读取。</li><li><code>~/.bash_profile</code>：每个用户都可使用该文件输入专用于自己使用的 shell 信息，当用户登录时，<strong>该文件仅仅执行一次</strong>。默认情况下，他设置一些环境变量，执行用户的 .bashrc 文件。</li><li><code>~/.bashrc</code>：该文件包含专用于你的 bash shell 的 bash 信息，当登录时以及每次打开新的 shell 时，该该文件被读取。</li><li><code>~/.bash_logout</code>：当每次退出系统(退出bash shell)时，执行该文件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;登录 Linux 时，会有 &lt;code&gt;/etc/profile&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;、&lt;code&gt;~/.bashrc&lt;/code&gt;等相关配置文件依次启动，本文以 Ubuntu 为例说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu， Linux， bashrc， profile， bash_profile" scheme="https://murphypei.github.io/tags/Ubuntu%EF%BC%8C-Linux%EF%BC%8C-bashrc%EF%BC%8C-profile%EF%BC%8C-bash-profile/"/>
    
  </entry>
  
  <entry>
    <title>Assert 在 Debug 和 Release 引起的问题</title>
    <link href="https://murphypei.github.io//blog/2020/01/assert-debug-release.html"/>
    <id>https://murphypei.github.io//blog/2020/01/assert-debug-release.html</id>
    <published>2020-01-17T08:56:49.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一次代码调试过程中，发现 Debug 和 Release 的结果不一致，由此引发的问题追溯…</p><a id="more"></a><p>因为 Debug 和 Release 不同，程序并没有报错，所以很容易想到是不是编译器做了什么操作导致编译的代码产生区别。</p><p>说实话，这次调试的过程是非常痛苦的，完全找不到头绪，最后通过一步步代码回退发现是 assert 的调用导致了问题。大概原理如下：</p><p>假设在一个循环中重复调用函数 <code>do_something</code>。这个函数在成功的情况下返回 0，失败则返回非 0 值。但是你完全不期望它在程序中<br>出现失败的情况。你可能会想这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">  assert (do_something () == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>不过，你可能发现这个运行时检查引入了不可承受的性能损失，并因此决定稍候指定 NDEBUG 以禁用运行时检测（Release 编译就等同于此）。这样做的结果是整个对 assert 的调用会被完全删除，也就是说，assert 宏的条件表达式将永远不会被执行，<code>do_something</code> 一次也不会被调用。因此，<strong>这样写才是正确的</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> status = do_something ();</span><br><span class="line">  assert (status == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步查询发现，在 <code>&lt;cassert&gt;</code> 头文件中，assert 的定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(condition) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(condition) <span class="comment">/*implementation defined*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也就是说 <code>assert</code> 语句在 Release 模式下是失效的…虽然程序继续运行了，但是结果不对。</p><p>这个问题弄了好久，但是说到底还是学艺不精，吃一堑长一智吧，记住 assert 的调用正确的写法，不过也可以牺牲部分性能定义一个检查的宏来代替 assert 的检查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一次代码调试过程中，发现 Debug 和 Release 的结果不一致，由此引发的问题追溯…&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="debug" scheme="https://murphypei.github.io/tags/debug/"/>
    
      <category term="assert" scheme="https://murphypei.github.io/tags/assert/"/>
    
      <category term="断言" scheme="https://murphypei.github.io/tags/%E6%96%AD%E8%A8%80/"/>
    
      <category term="宏" scheme="https://murphypei.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git-LFS 使用和迁移</title>
    <link href="https://murphypei.github.io//blog/2019/12/git-lfs.html"/>
    <id>https://murphypei.github.io//blog/2019/12/git-lfs.html</id>
    <published>2019-12-23T12:39:50.000Z</published>
    <updated>2020-12-10T21:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次 Git-LFS 的迁移记录。</p><a id="more"></a><p>网上说了一大堆 Git-LFS 的作用和好处，我觉得都是把官方文档零零碎碎翻译一下。在我看来，对于普通开发者而言，Git-LFS 的作用很简单，就是让你 <strong>pull 代码的时候不用每次都把一大堆大文件一块 pull 下来</strong>，而且我个人使用体验还有切换分支之类的操作都变快了。</p><h3 id="Git-LFS-安装"><a href="#Git-LFS-安装" class="headerlink" title="Git-LFS 安装"></a>Git-LFS 安装</h3><p><code>sudo apt/yum install git-lfs</code> 即可，然后 <code>git lfs install</code>。</p><h3 id="Git-LFS-使用"><a href="#Git-LFS-使用" class="headerlink" title="Git-LFS 使用"></a>Git-LFS 使用</h3><h4 id="追踪和推送"><a href="#追踪和推送" class="headerlink" title="追踪和推送"></a>追踪和推送</h4><p>在一个已经初始化后的 Git 仓库中使用 Git-LFS 来追踪大文件，命令如下：</p><p><code>git lfs track &lt;filepattern&gt;</code></p><p>track 会产生一个 <code>.gitattributes</code> 文件，和 <code>.gitignore</code> 类似，也是 git 自己的文件，用于描述 Git-LFS 的文件名匹配模板。一般而言，文件中的每一行类似这种：</p><p><code>*.pbtxt filter=lfs diff=lfs merge=lfs -text</code></p><p><code>-text</code> 就是表示这个文件<strong>不是文本文件</strong>。其余的就是告诉 Git 在处理 filter、diff、merge 时将 pbtxt 文件通过 LFS 的方式处理，打开 <code>.gitconfig</code> 可以看到相关命令的替换。</p><p>用 Git-LFS track 追踪档案之后，就可以添加、提交和推送到远端目录上，你在首次推上去的时候，会要一些时间将大型档案传输到远端。这里是很多教程很模糊的地方，事实上，Git-LFS 并不是什么魔法，仍然要将文件同步到远端。有的 git 仓库页面会显示 Git-LFS 的标记，gitlab 就可以，好评，tx 自用的工蜂，呵呵。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>其他用户使用这个仓库的时候，使用 <code>git clone</code> 会拉取普通的文件，但是 LFS 追踪的文件不会被拉下来。如果这些文件本地没有，则需要使用 <code>git lfs pull</code> 从远程仓库拉取。</p><blockquote><p>现在的 git 貌似是直接能够拉取所有文件，包括 lfs 文件，如果不想拉取 lfs 文件，可以使用 <code>GIT_LFS_SKIP_SMUDGE=1 git clone</code></p></blockquote><p>总结来看，Git-LFS 唯一的目的就是于其他 clone 使用者来说，他们若不需要异动大型档案，就不需要进行git lfs pull 的动作，于是那个原本的大型档案会变成一个130 bytes 的文字档。即使他clone 整个master，也是很小的储存库。Git-LFS 的使用无关档案大小，唯一的重点在于某些档案你想放在 master 内，或是说必须放在master 内，而其他人又不需要同步这个档案的话，就可以使用 Git-LFS 的方式来管理此档案。</p><h3 id="Git-LFS-迁移"><a href="#Git-LFS-迁移" class="headerlink" title="Git-LFS  迁移"></a>Git-LFS  迁移</h3><p>这个才是比较实用的，因为很多仓库是用着用着才想着用 lfs…</p><p>对于一个已经用了一段时间的 Git 仓库，直接执行  <code>git lfs migrate import --include=&quot;*.bin&quot; --everything</code> ，可以将所有本地分支上的匹配文件的提交历史版本都转换为 lfs，这个时候无论你切换到哪个分支，都会出现 <code>.gitattributes</code> 文件，且内容都是一样的。</p><blockquote><p>如果只想更新某个分支的话，可以使用 <code>git lfs migrate import --include=&quot;*.bin&quot; --include-ref=refs/heads/master</code></p></blockquote><p>可以通过 <code>git lfs ls-files</code> 查看哪些文件被转换成 lfs 了。</p><p>切换成功后，就需要把切换之后的本地分支提交到远程仓库了，需要手动 push 更新远程仓库中的各个分支。这里有个极大需要注意的地方，就是转换会更改所有提交的 hash，因此 push 的时候需要使用 force 选项，而当其他人员再次使用 pull 去远程拉取的时候会失败。这里当然可以使用 <code>pull --allow-unrelated-histories</code> 来把远程仓库被修改的历史与本地仓库历史做合并，但是最好是<strong>重新拉取</strong>。</p><p>切换成功后，git 仓库的大小可能并没有变化，主要是之前的提交还在，因此需要做一些清理工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog expire --expire-unreachable=now --all</span><br><span class="line">git gc --prune=now</span><br></pre></td></tr></table></figure><p>但是，<strong>如果不是历史记录非常重要的仓库，建议不要像上述这么做，而是重新建立一个新的仓库。个人经验，迁移可以使用，但并没那么美好</strong>。</p><p>附一个迁移相关的<a href="https://github.com/Git-LFS/Git-LFS/wiki/Tutorial" target="_blank" rel="noopener">基础教程</a></p><h3 id="Git-LFS-需要多次输入密码的问题"><a href="#Git-LFS-需要多次输入密码的问题" class="headerlink" title="Git-LFS 需要多次输入密码的问题"></a>Git-LFS 需要多次输入密码的问题</h3><p>解决 Git-LFS 使用导致 push 需要输入多次用户名和密码。</p><p>Linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set git to use the credential memory cache</span></span><br><span class="line">git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br><span class="line">git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br></pre></td></tr></table></figure><p>其他平台可以参考：<a href="https://help.github.com/en/github/using-git/caching-your-github-password-in-git" target="_blank" rel="noopener">Caching your GitHub password in Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次 Git-LFS 的迁移记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://murphypei.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://murphypei.github.io/tags/Git/"/>
    
      <category term="LFS" scheme="https://murphypei.github.io/tags/LFS/"/>
    
      <category term="migrate" scheme="https://murphypei.github.io/tags/migrate/"/>
    
      <category term=".gitattributes" scheme="https://murphypei.github.io/tags/gitattributes/"/>
    
  </entry>
  
</feed>
